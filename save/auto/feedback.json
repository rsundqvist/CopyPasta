[
  {
    "content": "%HEADER%\n\nPå lab 3 kan man få 6p som mest.\n\nGrupp: %GROUP%, inlämning 1\nPoäng: xx, accepterad  retur (inom 7 dagar) %MANUAL%\n\nBra men jag har en/några kommentar(er):\n------------------------------------------------------------------------------- \n\n:::::: Steg3: %FILE: Steg3.java% //Default, recommended\n\n:::::: CrystalModel: %File: CrystalModel.java \t% //Acceptable variant\n\n:::::: CrystalView: %file: \tCrystalView.java  \t% //Acceptable variant\n\n:::::: CrystalControl: %  \tFILE:CrystalControl.java  % //Acceptable variant\n\n\nHälsningar,\n%NAME%",
    "header": "",
    "teacher": "",
    "group": "11",
    "assignment": "",
    "files": {
      "comments.txt": "Hej\nKommentarerna som vi ger är försedda med ett prefix i form av ett tecken:\nFörstår du inte vad rättaren menar? Maila och fråga - vi bits inte :-)\n\nAlla kommentarer skall du rätta. Inga felanmärkningar skall naturligtvis \nupprepas i senare labbar.\n\n\"-\"   markerar en allvarlig kommentar som antagligen har resulterat i en retur.\n\"=\"   markerar en allvarlig kommentar som *inte* har resulterat i en retur utan\n\t  enbart poängavdrag. Många \"=\" kan också resultera i en retur.\n\"#\"   markerar en mindre allvarlig kommentar.\n\"*\"   kommentar, behöver ej åtgärdas.\n\"+\"   extra bra\n-------------------------------------------------------------------------------\nPoäng och returpolicy finns beskrivet under \"assignments->Lab acceptance rules\".\naccept på labben innebär att man inte kan lämna in igen \n(men inte att det är \"godkänd\")\nreject på labben att man kan eller måste lämna in igen och kan ev. få 1p till.\nOm du får retur på bara en uppgift, lämna bara in den uppgiften nästa gång.\n-------------------------------------------------------------------------------\n\nHej\nLab 3 kan ge max 6p.\n\nGrupp: 11, inlämning 2\nPoäng: 3, accepterad\n\nBra, här är mina kommentar(er):\n\nallmänt: \nBra jobbat!\n\nSteg3:\n\nCrystalControl: \n\nCrystalView:\n\nCrystalModel:\n\n\nRichard Sundqvist\n\n"
    },
    "done": false
  },
  {
    "content": "%HEADER%\n\nPå lab 3 kan man få 6p som mest.\n\nGrupp: %GROUP%, inlämning 1\nPoäng: xx, accepterad  retur (inom 7 dagar) %MANUAL%\n\nBra men jag har en/några kommentar(er):\n------------------------------------------------------------------------------- \n\n:::::: Steg3: %FILE: Steg3.java% //Default, recommended\n\n:::::: CrystalModel: %File: CrystalModel.java \t% //Acceptable variant\n\n:::::: CrystalView: %file: \tCrystalView.java  \t% //Acceptable variant\n\n:::::: CrystalControl: %  \tFILE:CrystalControl.java  % //Acceptable variant\n\n\nHälsningar,\n%NAME%",
    "header": "",
    "teacher": "",
    "group": "137",
    "assignment": "",
    "files": {
      "comments.txt": "Hej\nKommentarerna som vi ger är försedda med ett prefix i form av ett tecken:\nFörstår du inte vad rättaren menar? Maila och fråga - vi bits inte :-)\n\nAlla kommentarer skall du rätta. Inga felanmärkningar skall naturligtvis \nupprepas i senare labbar.\n\n\"-\"   markerar en allvarlig kommentar som antagligen har resulterat i en retur.\n\"=\"   markerar en allvarlig kommentar som *inte* har resulterat i en retur utan\n\t  enbart poängavdrag. Många \"=\" kan också resultera i en retur.\n\"#\"   markerar en mindre allvarlig kommentar.\n\"*\"   kommentar, behöver ej åtgärdas.\n\"+\"   extra bra\n-------------------------------------------------------------------------------\nPoäng och returpolicy finns beskrivet under \"assignments->Lab acceptance rules\".\naccept på labben innebär att man inte kan lämna in igen \n(men inte att det är \"godkänd\")\nreject på labben att man kan eller måste lämna in igen och kan ev. få 1p till.\nOm du får retur på bara en uppgift, lämna bara in den uppgiften nästa gång.\n-------------------------------------------------------------------------------\n\nHej\nLab 3 kan ge max 6p.\n\nGrupp: 137, inlämning 1\nPoäng: 3, accepterad\n\nBra, här är mina kommentar(er):\n\nallmänt: \n* Ta bort TODO:erna helt och hållet när de är behandlade.\n\n# Indenteringen är inte korrekt. Möjligtvis blandar ni spaces och tabbar. Titta\ngärna på automatisk indentering i IDE:er såsom Eclipse.\n\nSteg3:\n= Det finns ingen anledning att anropa new Steg3() här. Gör Ram2 till en statisk\nklass för att slippa skapa en värdelös Steg3 instans.\n\n= Kontrollera både att args faktiskt innehåller något (args.length > 0)\noch att args[0] är ett tal (try/catch IllegalNumberFormatException).\n\nCrystalControl: \n\nCrystalView:\n= Instansvariabler är ej privata.\n\nCrystalModel:\n= crystallizeOneIon() garanterar inte att en jon faktiskt kristalliseras, vilket\nju gör metodnamnet direkt felaktigt. Ni måste använda dropNewIon() igen i loopen\nom den går utanför flyktcirkeln.\n\nRichard Sundqvist\n\n"
    },
    "done": false
  },
  {
    "content": "%HEADER%\n\nPå lab 3 kan man få 6p som mest.\n\nGrupp: %GROUP%, inlämning 1\nPoäng: xx, accepterad  retur (inom 7 dagar) %MANUAL%\n\nBra men jag har en/några kommentar(er):\n------------------------------------------------------------------------------- \n\n:::::: Steg3: %FILE: Steg3.java% //Default, recommended\n\n:::::: CrystalModel: %File: CrystalModel.java \t% //Acceptable variant\n\n:::::: CrystalView: %file: \tCrystalView.java  \t% //Acceptable variant\n\n:::::: CrystalControl: %  \tFILE:CrystalControl.java  % //Acceptable variant\n\n\nHälsningar,\n%NAME%",
    "header": "",
    "teacher": "",
    "group": "143",
    "assignment": "",
    "files": {
      "comments.txt": "Hej\nKommentarerna som vi ger är försedda med ett prefix i form av ett tecken:\nFörstår du inte vad rättaren menar? Maila och fråga - vi bits inte :-)\n\nAlla kommentarer skall du rätta. Inga felanmärkningar skall naturligtvis \nupprepas i senare labbar.\n\n\"-\"   markerar en allvarlig kommentar som antagligen har resulterat i en retur.\n\"=\"   markerar en allvarlig kommentar som *inte* har resulterat i en retur utan\n\t  enbart poängavdrag. Många \"=\" kan också resultera i en retur.\n\"#\"   markerar en mindre allvarlig kommentar.\n\"*\"   kommentar, behöver ej åtgärdas.\n\"+\"   extra bra\n-------------------------------------------------------------------------------\nPoäng och returpolicy finns beskrivet under \"assignments->Lab acceptance rules\".\naccept på labben innebär att man inte kan lämna in igen \n(men inte att det är \"godkänd\")\nreject på labben att man kan eller måste lämna in igen och kan ev. få 1p till.\nOm du får retur på bara en uppgift, lämna bara in den uppgiften nästa gång.\n-------------------------------------------------------------------------------\n\nHej\nLab 3 kan ge max 6p.\n\nGrupp: 142, inlämning 2\nPoäng: 3, accepterad\n\nBra, här är mina kommentar(er):\n\nallmänt: \nBra jobbat!\n\nSteg3:\n\nCrystalControl: \n\nCrystalView:\n\nCrystalModel:\n\n\nRichard Sundqvist\n\n"
    },
    "done": false
  },
  {
    "content": "%HEADER%\n\nPå lab 3 kan man få 6p som mest.\n\nGrupp: %GROUP%, inlämning 1\nPoäng: xx, accepterad  retur (inom 7 dagar) %MANUAL%\n\nBra men jag har en/några kommentar(er):\n------------------------------------------------------------------------------- \n\n:::::: Steg3: %FILE: Steg3.java% //Default, recommended\n\n:::::: CrystalModel: %File: CrystalModel.java \t% //Acceptable variant\n\n:::::: CrystalView: %file: \tCrystalView.java  \t% //Acceptable variant\n\n:::::: CrystalControl: %  \tFILE:CrystalControl.java  % //Acceptable variant\n\n\nHälsningar,\n%NAME%",
    "header": "",
    "teacher": "",
    "group": "21",
    "assignment": "",
    "files": {
      "comments.txt": "Hej\nKommentarerna som vi ger är försedda med ett prefix i form av ett tecken:\nFörstår du inte vad rättaren menar? Maila och fråga - vi bits inte :-)\n\nAlla kommentarer skall du rätta. Inga felanmärkningar skall naturligtvis \nupprepas i senare labbar.\n\n\"-\"   markerar en allvarlig kommentar som antagligen har resulterat i en retur.\n\"=\"   markerar en allvarlig kommentar som *inte* har resulterat i en retur utan\n\t  enbart poängavdrag. Många \"=\" kan också resultera i en retur.\n\"#\"   markerar en mindre allvarlig kommentar.\n\"*\"   kommentar, behöver ej åtgärdas.\n\"+\"   extra bra\n-------------------------------------------------------------------------------\nPoäng och returpolicy finns beskrivet under \"assignments->Lab acceptance rules\".\naccept på labben innebär att man inte kan lämna in igen \n(men inte att det är \"godkänd\")\nreject på labben att man kan eller måste lämna in igen och kan ev. få 1p till.\nOm du får retur på bara en uppgift, lämna bara in den uppgiften nästa gång.\n-------------------------------------------------------------------------------\n\nHej\nLab 3 kan ge max 6p.\n\nGrupp: 21, inlämning 1\nPoäng: 0, retur (inom 7 dagar)\n\nBra, här är mina kommentar(er):\n\nallmänt: \n- Kraven under \"Specialla krav\" är krav, inte förslag:\n\"Simuleringen startas med java Steg3 size däre size är bredden och höjden på badet\"\n\nDet är helt OK att ha extra finesser såsom sliders men programmet ska fortfarande\ndelas upp på ett vettigt sätt.\n\nSkapa klasserna i separata filer (undantag t.ex. action listeners, inte relevant\ni ert fall när ni använder lamba notation) och lämna in igen. Hela tanken med\nMVC är just att saker såsom GUI inte ska ligga i modellen.\n\nNi bör (ska) ha separata klasser för Model, View samt Control i egna filer.\n\nSteg3:\n\nCrystalControl: \n\nCrystalView:\n\nCrystalModel:\n\n\nRichard Sundqvist\n\n"
    },
    "done": false
  },
  {
    "content": "%HEADER%\n\nPå lab 3 kan man få 6p som mest.\n\nGrupp: %GROUP%, inlämning 1\nPoäng: xx, accepterad  retur (inom 7 dagar) %MANUAL%\n\nBra men jag har en/några kommentar(er):\n------------------------------------------------------------------------------- \n\n:::::: Steg3: %FILE: Steg3.java% //Default, recommended\n\n:::::: CrystalModel: %File: CrystalModel.java \t% //Acceptable variant\n\n:::::: CrystalView: %file: \tCrystalView.java  \t% //Acceptable variant\n\n:::::: CrystalControl: %  \tFILE:CrystalControl.java  % //Acceptable variant\n\n\nHälsningar,\n%NAME%",
    "header": "",
    "teacher": "",
    "group": "26",
    "assignment": "",
    "files": {
      "comments.txt": "Hej\nKommentarerna som vi ger är försedda med ett prefix i form av ett tecken:\nFörstår du inte vad rättaren menar? Maila och fråga - vi bits inte :-)\n\nAlla kommentarer skall du rätta. Inga felanmärkningar skall naturligtvis \nupprepas i senare labbar.\n\n\"-\"   markerar en allvarlig kommentar som antagligen har resulterat i en retur.\n\"=\"   markerar en allvarlig kommentar som *inte* har resulterat i en retur utan\n\t  enbart poängavdrag. Många \"=\" kan också resultera i en retur.\n\"#\"   markerar en mindre allvarlig kommentar.\n\"*\"   kommentar, behöver ej åtgärdas.\n\"+\"   extra bra\n-------------------------------------------------------------------------------\nPoäng och returpolicy finns beskrivet under \"assignments->Lab acceptance rules\".\naccept på labben innebär att man inte kan lämna in igen \n(men inte att det är \"godkänd\")\nreject på labben att man kan eller måste lämna in igen och kan ev. få 1p till.\nOm du får retur på bara en uppgift, lämna bara in den uppgiften nästa gång.\n-------------------------------------------------------------------------------\n\nHej\nLab 3 kan ge max 6p.\n\nGrupp: 26, inlämning 1\nPoäng: 5, accepterad\n\nBra, här är mina kommentar(er):\n\nallmänt: \n\nSteg3:\n= Index out of bounds hanteras med if-satser, inte try/catch.\n\nCrystalControl: \n# \"input\" är inte ett bra namn för hastigheten.\n\nCrystalView:\n\nCrystalModel:\n# L210: Ni använder booleaner konstigt. Kod på formen\n\n    if (a < b) {\n        return true;\n    } else {\n       return false;\n    }\n\t\nKan och bör skrivas\n    return a < b;\n\nRichard Sundqvist\n\n",
      "Head.cs": "using System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\nusing System.Threading;\nusing System.Threading.Tasks;\nusing System.Windows.Forms;\nusing ObjectSerializerLibrary;\nusing ThreeDimensionalVisualizationLibrary.Faces;\nusing ThreeDimensionalVisualizationLibrary.Objects;\n\nnamespace VS1\n{\n    class Head : Object3D\n    {\n        private readonly Eye _leftEye, _rightEye;\n        private const double AnimationStepLength = 0.1;\n        private const int SleepDuration = 20;\n\n        public Head()\n        {\n            Object3DList = new List<Object3D>();\n\n            string path = Path.GetDirectoryName(Application.ExecutablePath) + \"..\\\\..\\\\..\\\\head.xml\";\n            Face face = (Face)ObjectXmlSerializer.ObtainSerializedObject(path, typeof(Face));\n            face.Name = \"face\";\n            face.Generate(new List<double> { 512 });\n            face.ShowWireFrame = false;\n            face.ShowSurfaces = true;\n            face.Visible = true;\n            face.SpecularColor = System.Drawing.Color.Bisque;\n            face.Object3DList = new List<Object3D>();\n\n            _leftEye = new Eye(\"leftEye\", 1);\n            _rightEye = new Eye(\"rightEye\", -1);\n\n            Object3DList.Add(face);\n            Object3DList.Add(_leftEye);\n            Object3DList.Add(_rightEye);\n        }\n\n        public void Blink(double d)\n        {\n            Thread t1 = new Thread(() => _leftEye.Blink(d));\n            Thread t2 = new Thread(() => _rightEye.Blink(d));\n            t1.Start();\n            t2.Start();\n        }\n\n        public void No(double d, int shakes)\n        {\n            Thread t = new Thread(() => NoLoop(d, shakes));\n            t.Start();\n        }\n\n        public void LookLeft(double d)\n        {\n            Thread t1 = new Thread(() => _leftEye.Look(d, 1));\n            Thread t2 = new Thread(() => _rightEye.Look(d, 1));\n            t1.Start();\n            t2.Start();\n        }\n\n        public void LookRight(double d)\n        {\n            Thread t1 = new Thread(() => _leftEye.Look(d, -1));\n            Thread t2 = new Thread(() => _rightEye.Look(d, -1));\n            t1.Start();\n            t2.Start();\n        }\n\n        private void NoLoop(double t, int shakes)\n        {\n            int n = (int)(0.5 * t / AnimationStepLength + 0.5);\n            double dz = 90.0 / n;\n\n            for (int i = 0; i < shakes; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    RotateZ(dz);\n                    Thread.Sleep(SleepDuration);\n                }\n                for (int j = -n; j < n; j++)\n                {\n                    RotateZ(-dz);\n                    Thread.Sleep(SleepDuration);\n                }\n                for (int j = 0; j < n; j++)\n                {\n                    RotateZ(dz);\n                    Thread.Sleep(SleepDuration);\n                }\n            }\n        }\n\n        public void Yes(double d, int shakes)\n        {\n            Thread t = new Thread(() => YesLoop(d, shakes));\n            t.Start();\n        }\n\n        private void YesLoop(double t, int shakes)\n        {\n            int n = (int)(0.5 * t / AnimationStepLength + 0.5);\n            int nUp = (int)(n * 1.3 + 0.5);\n            double dx = 45.0 / n;\n\n            for (int i = 0; i < shakes; i++)\n            {\n                for (int j = 0; j < n; j++)\n                {\n                    RotateX(-dx);\n                    Thread.Sleep(SleepDuration);\n                }\n                for (int j = 0; j < nUp; j++)\n                {\n                    RotateX(dx);\n                    Thread.Sleep(SleepDuration);\n                }\n\n                for (int j = 0; j < nUp - n; j++)\n                {\n                    RotateX(-dx);\n                    Thread.Sleep(SleepDuration);\n                }\n            }\n        }\n\n        internal void Sad()\n        {\n            Yes(15, 1);\n            Blink(15);\n            TorusSector3D leftBrow = _leftEye.GetEyebrow();\n            TorusSector3D rightBrow = _rightEye.GetEyebrow();\n\n            Thread t = new Thread(() =>\n            {\n                for (int i = 0; i < 100; i++)\n                {\n                    leftBrow.RotateY(-0.25);\n                    rightBrow.RotateY(0.25);\n                    leftBrow.Move(-0.001, 0, 0);\n                    rightBrow.Move(0.001, 0, 0);\n                    Thread.Sleep(10);\n                }\n                Thread.Sleep(1000);\n                for (int i = 0; i < 100; i++)\n                {\n                    leftBrow.RotateY(0.25);\n                    rightBrow.RotateY(-0.25);\n                    leftBrow.Move(0.001, 0, 0);\n                    rightBrow.Move(-0.001, 0, 0);\n                    Thread.Sleep(10);\n                }\n            });\n            t.Start();\n        }\n    }\n}\n"
    },
    "done": false
  },
  {
    "content": "%HEADER%\n\nPå lab 3 kan man få 6p som mest.\n\nGrupp: %GROUP%, inlämning 1\nPoäng: xx, accepterad  retur (inom 7 dagar) %MANUAL%\n\nBra men jag har en/några kommentar(er):\n------------------------------------------------------------------------------- \n\n:::::: Steg3: %FILE: Steg3.java% //Default, recommended\n\n:::::: CrystalModel: %File: CrystalModel.java \t% //Acceptable variant\n\n:::::: CrystalView: %file: \tCrystalView.java  \t% //Acceptable variant\n\n:::::: CrystalControl: %  \tFILE:CrystalControl.java  % //Acceptable variant\n\n\nHälsningar,\n%NAME%",
    "header": "",
    "teacher": "",
    "group": "67",
    "assignment": "",
    "files": {
      "comments.txt": "Hej\nKommentarerna som vi ger är försedda med ett prefix i form av ett tecken:\nFörstår du inte vad rättaren menar? Maila och fråga - vi bits inte :-)\n\nAlla kommentarer skall du rätta. Inga felanmärkningar skall naturligtvis \nupprepas i senare labbar.\n\n\"-\"   markerar en allvarlig kommentar som antagligen har resulterat i en retur.\n\"=\"   markerar en allvarlig kommentar som *inte* har resulterat i en retur utan\n\t  enbart poängavdrag. Många \"=\" kan också resultera i en retur.\n\"#\"   markerar en mindre allvarlig kommentar.\n\"*\"   kommentar, behöver ej åtgärdas.\n\"+\"   extra bra\n-------------------------------------------------------------------------------\nPoäng och returpolicy finns beskrivet under \"assignments->Lab acceptance rules\".\naccept på labben innebär att man inte kan lämna in igen \n(men inte att det är \"godkänd\")\nreject på labben att man kan eller måste lämna in igen och kan ev. få 1p till.\nOm du får retur på bara en uppgift, lämna bara in den uppgiften nästa gång.\n-------------------------------------------------------------------------------\n\nHej\nLab 3 kan ge max 6p.\n\nGrupp: 67, inlämning 1\nPoäng: 6, accepterad\n\nBra, här är mina kommentar(er):\n\nallmänt: \nBra jobbat!\n\nSteg3:\n\nCrystalControl: \n\nCrystalView:\n\nCrystalModel:\n\n\nRichard Sundqvist\n\n"
    },
    "done": false
  },
  {
    "content": "%HEADER%\n\nPå lab 3 kan man få 6p som mest.\n\nGrupp: %GROUP%, inlämning 1\nPoäng: xx, accepterad  retur (inom 7 dagar) %MANUAL%\n\nBra men jag har en/några kommentar(er):\n------------------------------------------------------------------------------- \n\n:::::: Steg3: %FILE: Steg3.java% //Default, recommended\n\n:::::: CrystalModel: %File: CrystalModel.java \t% //Acceptable variant\n\n:::::: CrystalView: %file: \tCrystalView.java  \t% //Acceptable variant\n\n:::::: CrystalControl: %  \tFILE:CrystalControl.java  % //Acceptable variant\n\n\nHälsningar,\n%NAME%",
    "header": "",
    "teacher": "",
    "group": "69",
    "assignment": "",
    "files": {
      "comments.txt": "Hej\nKommentarerna som vi ger är försedda med ett prefix i form av ett tecken:\nFörstår du inte vad rättaren menar? Maila och fråga - vi bits inte :-)\n\nAlla kommentarer skall du rätta. Inga felanmärkningar skall naturligtvis \nupprepas i senare labbar.\n\n\"-\"   markerar en allvarlig kommentar som antagligen har resulterat i en retur.\n\"=\"   markerar en allvarlig kommentar som *inte* har resulterat i en retur utan\n\t  enbart poängavdrag. Många \"=\" kan också resultera i en retur.\n\"#\"   markerar en mindre allvarlig kommentar.\n\"*\"   kommentar, behöver ej åtgärdas.\n\"+\"   extra bra\n-------------------------------------------------------------------------------\nPoäng och returpolicy finns beskrivet under \"assignments->Lab acceptance rules\".\naccept på labben innebär att man inte kan lämna in igen \n(men inte att det är \"godkänd\")\nreject på labben att man kan eller måste lämna in igen och kan ev. få 1p till.\nOm du får retur på bara en uppgift, lämna bara in den uppgiften nästa gång.\n-------------------------------------------------------------------------------\n\nHej\nLab 3 kan ge max 6p.\n\nGrupp: 69, inlämning 1\nPoäng: 4, accepterad\n\nBra, här är mina kommentar(er):\n\nallmänt: \n* Ta bort TODO:erna helt och hållet när de är klara.\n\nSteg3:\n= Kontrollera både att args faktiskt innehåller något (args.length > 0)\noch att args[0] är ett tal (try/catch IllegalNumberFormatException).\n\nCrystalControl: \n# Använd timer.start(), timer.stop(), inte booleanen \"isRunning\". Det är det\ntimer är till för.\n\nCrystalView:\n= Instansvariabler är ej privata.\n\nCrystalModel:\n\n\nRichard Sundqvist\n\n",
      "Navigation.cpp": "/**\n * Copyright (C) 2016 Chalmers Revere\n *\n * This program is free software; you can redistribute it and/or\n * modify it under the terms of the GNU General Public License\n * as published by the Free Software Foundation; either version 2\n * of the License, or (at your option) any later version.\n *\n * This program is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with this program; if not, write to the Free Software\n * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301,\n * USA.\n */\n\n#include <cstdlib>\n#include <iostream>\n#include <algorithm>\n#include <fstream>\n\n#include <opendavinci/odcore/base/KeyValueConfiguration.h>\n#include <opendavinci/odcore/base/Lock.h>\n#include <opendavinci/odcore/data/Container.h>\n#include <opendavinci/odcore/strings/StringToolbox.h>\n\n#include <opendavinci/odcore/wrapper/Eigen.h>\n\n#include <odvdopendlvdata/GeneratedHeaders_ODVDOpenDLVData.h>\n#include <odvdminiature/GeneratedHeaders_ODVDMiniature.h>\n\n#include \"Navigation.h\"\n\nnamespace opendlv {\nnamespace logic {\nnamespace miniature {\n\n/*\n Constructor.\n */\nNavigation::Navigation(const int &argc, char **argv) :\n        TimeTriggeredConferenceClientModule(argc, argv, \"logic-miniature-navigation\"), m_mutex(), m_outerWalls(), m_innerWalls(), m_pointsOfInterest(), m_analogReadings(), m_gpioReadings(), m_gpioOutputPins(), m_pwmOutputPins(), m_pingDistance(\n                500.0), m_posX(0.0), m_posY(0.0), m_yaw(0.0), m_collisionTime() {\n}\n\n/*\n This method reads values from the configuration file. Note that there is only\n one global configuration storage loaded by the central odsupercomponent\n module. If the the configuration file is changed, the odsupercompnent module\n needs to be restarted.\n */\nvoid Navigation::setUp() {\n    odcore::base::KeyValueConfiguration kv = getKeyValueConfiguration();\n    std::string const gpioPinsString = kv.getValue < std::string > (\"logic-miniature-navigation.gpio-pins\");\n    std::vector < std::string > gpioPinsVector = odcore::strings::StringToolbox::split(gpioPinsString, ',');\n    for (auto pin : gpioPinsVector) {\n        m_gpioOutputPins.push_back(std::stoi(pin));\n    }\n\n    std::string const pwmPinsString = kv.getValue < std::string > (\"logic-miniature-navigation.pwm-pins\");\n    std::vector < std::string > pwmPinsVector = odcore::strings::StringToolbox::split(pwmPinsString, ',');\n    for (auto pin : pwmPinsVector) {\n        m_pwmOutputPins.push_back(std::stoi(pin));\n    }\n\n    std::string const outerWallsString = kv.getValue < std::string > (\"logic-miniature-navigation.outer-walls\");\n    std::vector < data::environment::Point3 > outerWallPoints = ReadPointString(outerWallsString);\n    if (outerWallPoints.size() == 4) {\n        m_outerWalls.push_back(data::environment::Line(outerWallPoints[0], outerWallPoints[1]));\n        m_outerWalls.push_back(data::environment::Line(outerWallPoints[1], outerWallPoints[2]));\n        m_outerWalls.push_back(data::environment::Line(outerWallPoints[2], outerWallPoints[3]));\n        m_outerWalls.push_back(data::environment::Line(outerWallPoints[3], outerWallPoints[0]));\n\n        //std::cout << \"Outer walls 1 - \" << m_outerWalls[0].toString() << std::endl;\n        //std::cout << \"Outer walls 2 - \" << m_outerWalls[1].toString() << std::endl;\n        //std::cout << \"Outer walls 3 - \" << m_outerWalls[2].toString() << std::endl;\n        //std::cout << \"Outer walls 4 - \" << m_outerWalls[3].toString() << std::endl;\n    } else {\n        //std::cout << \"Warning: Outer walls format error. (\" << outerWallsString << \")\" << std::endl;\n    }\n\n    std::string const innerWallsString = kv.getValue < std::string > (\"logic-miniature-navigation.inner-walls\");\n    std::vector < data::environment::Point3 > innerWallPoints = ReadPointString(innerWallsString);\n    for (uint32_t i = 0; i < innerWallPoints.size(); i += 2) {\n        if (i < innerWallPoints.size() - 1) {\n            data::environment::Line innerWall(innerWallPoints[i], innerWallPoints[i + 1]);\n            m_innerWalls.push_back(innerWall);\n            //std::cout << \"Inner wall - \" << innerWall.toString() << std::endl;\n        }\n    }\n\n    std::string const pointsOfInterestString = kv.getValue < std::string\n            > (\"logic-miniature-navigation.points-of-interest\");\n    m_pointsOfInterest = ReadPointString(pointsOfInterestString);\n    for (uint32_t i = 0; i < m_pointsOfInterest.size(); i++) {\n        //std::cout << \"Point of interest \" << i << \": \" << m_pointsOfInterest[i].toString() << std::endl;\n    }\n}\n\n/*\n Destructor.\n */\nNavigation::~Navigation() {\n}\n\n/*\n This method is run automatically when the system is shutting down (before the\n destructor). It is typically used to close log files and de-allocate\n dynamically allocated memory.\n */\nvoid Navigation::tearDown() {\n    stop();\n}\n\n/*\n The while loop in this method runs at a predefined (in configuration)\n frequency.\n */\nodcore::data::dmcp::ModuleExitCodeMessage::ModuleExitCode Navigation::body() {\n    static const int LPS_POSITION_INDEX = 4;\n    static int CURRENT_POSITION_INDEX = LPS_POSITION_INDEX;\n    /*\n     0: FINISHED\n     1: SEARCHING\n     2: COLLISION HANDLING\n     */\n    int previousState = -1;\n    int state = 1;\n    \n\n    //Test graph - should not be present when running robot\n    //std::pair<std::vector<std::vector<double>>, std::vector<data::environment::Point3>> TEST = create(9, 7, m_pointsOfInterest, m_outerWalls, m_innerWalls);\n    //printTopo(TEST);\n    bool previousLpsState = !LPS_DOWN;\n\n    // =======================================================================//\n    // State 0 variables - FINISHED\n    // =======================================================================//\n\n    // =======================================================================//\n    // State 1 variables - SEARCHING\n    // =======================================================================//\n    int searchState = 0;\n    int targetPOI = -1;\n    int targetNode = 0;\n    int currentPathIndex = -1;\n    double headingTolerance = 0.05;\n    std::vector<int> path;\n    double turnTime = 0;\n    std::pair<std::vector<std::vector<double>>, std::vector<data::environment::Point3>> p;\n    \n    //int targetPOI_1 = 0;\n    //int targetPOI_2 = 1;\n\n    double targetDistanceTolerance = 1; // 10 cm?\n\n    // =======================================================================//\n    // State 2 variables - COLLISION HANDLING\n    // =======================================================================//\n    /* \n     0: New collision\n     1: At rest\n     2: Backing\n     3: Turn\n     */\n    int collisionState = 0;\n    double timeSinceCollision;\n    double static t1 = 2.0; // stop\n    double static t3 = 3.0; // back\n    double static t5 = 3.5; // left/right\n    double static t7 = 4.5; // back 2\n\n    //Add current position to POIs \n    \n    std::cout << m_currentPosition.getX() << \" \";\n    std::cout << m_currentPosition.getY() << std::endl;\n     \n    m_pointsOfInterest.push_back(m_currentPosition);\n    \n    //Trapped in middle\n    m_posX = 10;\n    m_posY = -15;\n    m_currentPosition.setX(m_posX);\n    m_currentPosition.setY(m_posY);\n    \n    std::cout << m_currentPosition.getX() << \" \";\n    std::cout << m_currentPosition.getY() << std::endl;\n    m_pointsOfInterest[m_pointsOfInterest.size()-1] = m_currentPosition;\n    \n    data::environment::Point3 foo = m_pointsOfInterest[m_pointsOfInterest.size()-1];\n    \n    std::cout << foo.getX() << \" \";\n    std::cout << foo.getY() << std::endl;\n    \n    // Log position every iteration\n\tofstream ofs(\"/opt/etdata/ego_trace.txt\", ofstream::out | ofstream::trunc);\n    ofs << \"ET = [\" << std::endl;\n\n    int numIterations = 0;\n    // ====================================================================== //\n    //                                                                        //\n    //                               MAIN LOOP                                //\n    //                                                                        //\n    // ====================================================================== //\n    while (getModuleStateAndWaitForRemainingTimeInTimeslice() == odcore::data::dmcp::ModuleStateMessage::RUNNING) {\n        numIterations++;\n        \n        std::cout << \"numIterations = \" << numIterations << std::endl;\n        if (numIterations > 200)\n            break;\n        \n        // The mutex is required since 'body' and 'nextContainer' competes by\n        // reading and writing to the class global maps, see also 'nextContainer'.\n        odcore::base::Lock l(m_mutex);\n        m_now = odcore::data::TimeStamp();\n        \n        ofs << m_posX << \" \" << m_posY << \" \" << m_yaw << endl;\n        \n        double timeSinceLastLpsSignal = timeSince(m_lastLpsSignal, m_now);\n        LPS_DOWN = timeSinceLastLpsSignal > m_lpsTimeout;\n        if (previousLpsState != LPS_DOWN){\n            previousLpsState = LPS_DOWN;\n            //std::cout << std::endl;\n            //std::cout << std::endl;\n            //std::cout << \"======================================================\" << std::endl;\n            //std::cout << \"======================================================\" << std::endl;\n            //std::cout << \"                 LPS_DOWN = \" << LPS_DOWN << std::endl;\n            //std::cout << \"======================================================\" << std::endl;\n            //std::cout << \"======================================================\" << std::endl;\n            //std::cout << std::endl;\n            //std::cout << std::endl;\n        }\n        \n        bool collision = detectCollision(m_pingDistance);\n        switch (state) {\n\n        // =================================================================//\n        // State 0 - FINISHED\n        // =================================================================//\n        case 0:\n            if (previousState != 0)\n                stop();\n            break;\n\n        // =================================================================//\n        // State 1 - SEARCHING\n        // =================================================================//\n        case 1:        \n            if (previousState != 1)\n                previousState = 1;\n\n            if (collision) {\n                state = 2;\n                searchState = 2; //Robot may be in a bad position after.\n                CURRENT_POSITION_INDEX = LPS_POSITION_INDEX;\n                ////std::cout << \"SEARCHING: Collision detected. Entering collision handler state.\" << std::endl;\n            } else {\n                \n            \n                double timeSpentTravelling = timeSince(m_targetChangeTime, m_now);\n                    \n                // Pick new target node.\n                if (searchState == 0) {\n                    targetPOI = (targetPOI + 1) % 4;\n                   \n                    std::cout << \"SEARCHING: New target POI: \" << targetPOI << std::endl;\n        \n                    searchState = 2;\n                \n                // Calculate path.\n                } else if (searchState == 2) {\n                    //std::cout << \"SEARCHING: Out of sync. Recalibrating.\" << std::endl;\n                    p = create(9, 7,m_pointsOfInterest, m_outerWalls, m_innerWalls);    \n                    m_adjMatrix = p.first;\n                    m_vert = p.second;\n    \n    \n                    //std::cout << \"CURRENT_POSITION_INDEX = \" << CURRENT_POSITION_INDEX << std::endl;\n       \n                            data::environment::Point3 cpos = m_vert[CURRENT_POSITION_INDEX];\n                            //std::cout << cpos.getX() << \" \";\n                            //std::cout << cpos.getY() << std::endl;\n                    //std::cout << \" ======================================= \" << std::endl;\n                            \n                    \n                    path = getNodeSequence(CURRENT_POSITION_INDEX, targetPOI, dijk(CURRENT_POSITION_INDEX, p.first));\n                    \n                    std::cout << \"path: = [ \";\n                    \n                    for(std::vector<int>::iterator it = path.begin(); it != path.end(); ++it)\n                        std::cout << *it << \" \";\n                        \n                    std::cout << \"]\" << std::endl;\n                    \n                    for(std::vector<int>::iterator it = path.begin(); it != path.end(); ++it){       \n                            //std::cout << *it << \" \" ;\n                            data::environment::Point3 v = m_vert[*it];\n                            std::cout << v.getX() << \" \";\n                            std::cout << v.getY() << std::endl;\n                    }\n                    std::cout << std::endl;\n                    \n                    while (path.empty())  {\n                        double oldX = m_posX;\n                        double oldY = m_posY;\n                        m_posX += -2 + 2*std::rand()%3;\n                        m_posY += -2 + 2*std::rand()%3;\n                        m_currentPosition.setX(m_posX);\n                        m_currentPosition.setY(m_posY);\n                        m_pointsOfInterest[m_pointsOfInterest.size()-1] = m_currentPosition;\n\n                        std::cout << \"BAD POSITION: TELEPORTING!\" << std::endl;\n                        std::cout << \"\\t(\" << oldX << \", \" << oldY << \") --> (\" << m_posX << \", \" << m_posY << \")\" << std::endl;\n                        \n                        // Try again\n                        \n                        p = create(9, 7, m_pointsOfInterest, m_outerWalls, m_innerWalls);    \n                        m_adjMatrix = p.first;\n                        m_vert = p.second;\n                        path = getNodeSequence(CURRENT_POSITION_INDEX, targetPOI, dijk(CURRENT_POSITION_INDEX, p.first));\n        \n                        //std::cout << \"CURRENT_POSITION_INDEX = \" << CURRENT_POSITION_INDEX << std::endl;\n                        cpos = m_vert[CURRENT_POSITION_INDEX];\n                        //std::cout << cpos.getX() << \" \";\n                        //std::cout << cpos.getY() << std::endl;\n                        //std::cout << \" ======================================= \" << std::endl;\n                    }\n                    \n                    currentPathIndex = 1; //Index 0 is always the current position\n                    targetNode = path[currentPathIndex];      \n                    setTargetNode(targetNode);\n                                                \n                    searchState = 3; //Turn to appropriate direction\n                // Correct heading.\n                } else if (searchState == 3) {\n                    double diff = m_targetHeading - m_yaw;\n                    \n                    while (diff < 0)\n                        diff += 3.14159265359;\n                        \n                    while (diff > 2*3.14159265359)\n                        diff -= 3.14159265359;\n                        \n                    turnTime = diff/TURN_RATE;\n                    \n                    if (std::abs(m_targetHeading - m_yaw) > headingTolerance) {\n                        left();\n                        searchState = 31;\n                        //std::cout << \"SEARCHING: Bad heading angle (ACTUAL, WANTED) = (\" << m_yaw << \", \" << m_targetHeading << \"). Turning for \" << turnTime << \" sec.\"<< std::endl;\n                        m_beginTurningTime = m_now;\n                    } else {\n                        searchState = 4;\n                        m_targetChangeTime = m_now;\n                        forward();\n                        //std::cout << \"SEARCHING: Heading angle withing acceptable bounds.\" << std::endl;\n                    }\n                    \n                // Correct heading helper.\n                } else if (searchState == 31) {\n                    double timeSpentTurning = timeSince(m_beginTurningTime, m_now);\n                    //std::cout << \"timeSpentTurning = \" << timeSpentTurning << std::endl;\n                    //std::cout << \"turnTime = \" << turnTime << std::endl;\n                    \n                    if (std::abs(m_targetHeading - m_yaw) <= headingTolerance || turnTime < timeSpentTurning) {\n                        \n                        //std::cout << \"SEARCHING 31: Heading angle withing acceptable bounds.\" << std::endl;\n                        searchState = 3;\n                        stop();\n                        if (LPS_DOWN)\n                            m_yaw = m_targetHeading;\n                    } else {\n                        if (LPS_DOWN) {\n                            //std::cout << \"LPS_DOWN: SPOOFED COORDINATES\" << std::endl;\n                            double dyaw = 0.05;\n                            \n                            if (m_targetHeading > m_yaw)\n                                m_yaw += dyaw;\n                            else\n                                m_yaw -= dyaw;\n                                \n                        }\n                        \n                        //std::cout << \"SEARCHING: (yawDesired, yawCurrent, currentTurntime, turnTime) = (\" << m_targetHeading << \", \" << m_yaw << \", \" << timeSpentTurning << \", \"<< turnTime<<\")\" << std::endl;\n                    }\n                \n                // Move forward until times up.\n                } else if (searchState == 4) {\n                    \n\n                    data::environment::Point3 targetOffset = m_currentPosition - m_targetPosition;\n                    if (timeSpentTravelling > m_travelTimeEstimate || targetOffset.lengthXY() <= targetDistanceTolerance)\n                        searchState = 5;\n                    else {\n                        ////std::cout << \"SEARCHING: Continue forward (\" << timeSpentTravelling << \" <= \" <<  m_travelTimeEstimate << \") | time <= est_time\" << std::endl;\n                        if (LPS_DOWN) {\n                            double dt = 1/getFrequency();\n                            m_posX += std::cos(m_yaw)*m_speed*dt;\n                            m_posY += std::sin(m_yaw)*m_speed*dt;\n                            m_currentPosition.setX(m_posX);\n                            m_currentPosition.setY(m_posY);\n                            m_pointsOfInterest[m_pointsOfInterest.size()-1] = m_currentPosition;\n                        }\n                    }\n                    \n                // Reached target?\n                } else if (searchState == 5) {\n                    data::environment::Point3 targetOffset = m_currentPosition - m_targetPosition;\n                    //std::cout << \"SEARCHING: Distance from target: \" << targetOffset.lengthXY() << std::endl;\n                    if (targetOffset.lengthXY() > targetDistanceTolerance) {\n                        //Didn't reach expected target - recallibrate\n                        //std::cout << \"SEARCHING: Failed to reach target node: \" << timeSpentTravelling << \"/\" << m_travelTimeEstimate << std::endl;\n                        searchState = 2;\n                        CURRENT_POSITION_INDEX = LPS_POSITION_INDEX;\n                        \n                        //std::cout << \"(x, y, m_yaw) = (\" << m_posX << \", \" << m_posY << \", \" << m_yaw << \")\" << std::endl;\n                        //std::cout << \"TARGET: (x, y, m_targetHeading) = (\" << m_targetPosition.getX() << \", \" << m_targetPosition.getY() << \", \" << m_targetHeading << \")\" << std::endl;\n                    } else {\n                        //std::cout << \"SEARCHING: Reached target node: \" << targetNode << \" after \" << timeSpentTravelling << \" seconds. \" << std::endl;\n                        CURRENT_POSITION_INDEX = targetNode;\n                        \n                        for(std::vector<int>::iterator it = path.begin(); it != path.end(); ++it){\n                           \n                            //std::cout << *it << \" \" ;\n                            data::environment::Point3 v = m_vert[*it];\n                            //std::cout << v.getX() << \" \";\n                            //std::cout << v.getY() << std::endl;\n                        }\n                        //std::cout << std::endl;\n                        stop();\n\n                        if (targetNode < 4) {\n                            //std::cout << \"SEARCHING: Reached target POI: \" << targetPOI << std::endl;\n                            //TODO Signal target reached? Maybe optional.\n                            searchState = 0;\n                        } else {\n                            //Estimate time to reach target\n                            currentPathIndex++;\n                            targetNode = path[currentPathIndex];\n                            setTargetNode(targetNode);\n                            searchState = 3; //Turn to appropriate direction\n                        }\n                    }\n                } else {\n                    //std::cout << \"SEARCHING: BAD STATE: \" << searchState << std::endl;\n                }\n            }\n            break;\n\n        // =================================================================//\n        // State 2 - COLLISION HANDLING\n        // =================================================================//\n        case 2:\n            timeSinceCollision = timeSince(m_collisionTime, m_now);\n\n            // Begin stop-and-wait\n            if (collisionState == 0) {\n                previousState = 2;\n                m_collisionTime = m_now;\n                stop();\n                collisionState = 1;\n                //std::cout << \"COLLISION: Stopping for \" << t1 << \" for seconds.\" << std::endl;\n            } else if (collisionState == 1) {\n                if (timeSinceCollision > t1) {\n                    if (collision) {\n                        collisionState = 3;\n                    } else {\n                        collisionState = -1;\n                        //std::cout << \"COLLISION: Obstacle no longer present.\" << std::endl;\n                    }\n                }\n\n                // Begin backing\n            } else if (collisionState == 3) {\n                //std::cout << \"COLLISION: Backing for \" << (t3 - t1) << \" for seconds.\" << std::endl;\n                back();\n                collisionState = 4;\n            } else if (collisionState == 4) {\n                if (timeSinceCollision > t3)\n                    collisionState = 5;\n\n                // Begin turning\n            } else if (collisionState == 5) {\n                if (rand() % 2) {\n                    //std::cout << \"COLLISION: Turning left for \" << (t5 - t3) << \" seconds.\" << std::endl;\n                    left();\n                } else {\n                    //std::cout << \"COLLISION: Turning right for \" << (t5 - t3) << \" seconds.\" << std::endl;\n                    right();\n                }\n                collisionState = 6;\n            } else if (collisionState == 6) {\n                if (timeSinceCollision > t5)\n                    collisionState = 7;\n\n            } else if (collisionState == 7) {\n                back();\n                //std::cout << \"COLLISION: Backing for \" << (t7 - t5) << \" seconds.\" << std::endl;\n                collisionState = 8;\n            } else if (collisionState == 8) {\n                if (timeSinceCollision > t7)\n                    collisionState = -1;\n                // Return to search state\n            } else {\n                //std::cout << \"COLLISION: Handling complete. Returning to search state.\" << std::endl;\n                collisionState = 0;\n                state = 1;\n                stop();\n            }\n            break;\n        // =================================================================//\n        // Default state - should never be reached\n        // =================================================================//\n        default:\n            //std::cout << \"BAD STATE: \" << state << std::endl;\n            stop();\n            return odcore::data::dmcp::ModuleExitCodeMessage::OKAY;\n            break;\n        }\n    }\n\n    ofs << \"];\" << std::endl;\n    ofs.close();\n    \n    //std::cout << \"Log printed to desktop: \\\"ego_trace.txt\\\"\" << std::endl;\n    return odcore::data::dmcp::ModuleExitCodeMessage::OKAY;\n}\n\nvoid Navigation::setTargetNode(int node) {\n    m_targetPosition = m_vert[node];\n\n    std::pair<double, double> headingAndDistance = getHeadingAndDistance(m_currentPosition, m_targetPosition);\n    m_travelTimeEstimate = headingAndDistance.second / m_speed + 0.5;\n    m_targetHeading = headingAndDistance.first;\n\n    //std::cout << \"SEARCHING: New target node: \" << node << \" | TIME EST: \" << m_travelTimeEstimate << std::endl;    \n    ////std::cout << \"SET TARGET NODE m_targetHeading: \" << m_targetHeading << \" | TIME EST: \" << m_travelTimeEstimate << std::endl;    \n}\n\nstd::pair<double, double> Navigation::getHeadingAndDistance(data::environment::Point3 & from, data::environment::Point3 & to) {\n    data::environment::Point3 diff = to - from;\n\n    double heading = diff.getAngleXY();\n    double distance = diff.lengthXY();\n\n    /*//std::cout << \"heading: \" << heading << std::endl;\n    if (diff.getX() < 0)\n        heading += 3.14159265359;\n*/\n    return std::pair<double, double>(heading, distance);\n}\n\ndouble Navigation::timeSince(odcore::data::TimeStamp from, odcore::data::TimeStamp to) {\n    return static_cast<double>(to.toMicroseconds() - from.toMicroseconds()) / 1000000.0;;\n}\n\nstd::pair<std::vector<std::vector<double>>, std::vector<data::environment::Point3>> Navigation::create(int m, int n,\n        const std::vector<data::environment::Point3> & pointsOfInterest,\n        const std::vector<data::environment::Line> & outerWalls, std::vector<data::environment::Line> innerWalls) {\n\n    // Find limits   \n    double maxX = -std::numeric_limits<double>::max();\n    double maxY = -std::numeric_limits<double>::max();\n    double minX = std::numeric_limits<double>::max();\n    double minY = std::numeric_limits<double>::max();\n\n    for (std::size_t i = 0; i < outerWalls.size(); i++) {\n        data::environment::Point3 pA = outerWalls[i].getA();\n        data::environment::Point3 pB = outerWalls[i].getB();\n\n        double Ax = pA.getX();\n        double Bx = pB.getX();\n        double Ay = pA.getY();\n        double By = pB.getY();\n\n        minX = std::min(minX, std::min(Ax, Bx));\n        minY = std::min(minY, std::min(Ay, By));\n\n        maxX = std::max(maxX, std::max(Ax, Bx));\n        maxY = std::max(maxY, std::max(Ay, By));\n    }\n\n    minX += 1;\n    minY += 1;\n\n    // Create vertices       \n    std::vector < data::environment::Point3 > nodes(pointsOfInterest); //Copy constructor\n\n    double dx = (maxX - minX) / n;\n    double dy = (maxY - minY) / m;\n    for (int i = 0; i < n; i++) {\n        for (int j = 0; j < m; j++) {\n            data::environment::Point3 newPoint(minX + dx * i, minY + dy * j, 0);\n            nodes.push_back(newPoint);\n        }\n    }\n\n    //Add outer walls to inner\n    std::vector < data::environment::Line > allWalls(innerWalls);\n    allWalls.insert(allWalls.end(), outerWalls.begin(), outerWalls.end());\n\n    // Create edges   \n    std::size_t s = nodes.size();\n    std::vector<std::vector<double>> edges(s);\n    data::environment::Point3 intersectPoint; // Used for debug only\n    int numBad = 0;\n    int numGood = 0;\n    for (uint32_t i = 0; i < s; i++) {\n        data::environment::Point3 pA = nodes[i]; //Vert A\n\n        for (uint32_t j = 0; j < s; j++) {\n            data::environment::Point3 pB = nodes[j]; //Vert B\n            data::environment::Line edge(pA, pB);\n            bool badEdge = false;\n\n            //Make sure edge doesnt intersect with a wall.\n            for (std::vector<data::environment::Line>::const_iterator k = allWalls.begin(); k < allWalls.end(); k++) {\n\n                badEdge = ((i == j) || edge.intersectIgnoreZ(*k, intersectPoint));\n\n                if (badEdge && i != j) {\n                    double eps = 0.05;\n\n                    double ix = intersectPoint.getX();\n                    double lminX = std::min(pA.getX(), pB.getX()) - eps;\n                    double lmaxX = std::max(pA.getX(), pB.getX()) + eps;\n\n                    double iy = intersectPoint.getY();\n                    double lminY = std::min(pA.getY(), pB.getY()) - eps;\n                    double lmaxY = std::max(pA.getY(), pB.getY()) + eps;\n\n                    badEdge = (ix >= lminX && ix <= lmaxX) && (iy >= lminY && iy <= lmaxY);\n                }\n\n                if (badEdge) {\n                    edges[i].push_back(std::numeric_limits<double>::infinity()); //Cost = inf <=> no edge\n                    numBad++;\n                    break;\n                }\n            }\n            if (!badEdge) {\n                edges[i].push_back(pA.getDistanceTo(pB));\n                numGood++;\n            }\n        }\n    }\n\n    return std::pair<std::vector<std::vector<double>>, std::vector<data::environment::Point3>>(edges, nodes);\n}\n\nvoid Navigation::printTopo(\n        std::pair<std::vector<std::vector<double>>, std::vector<data::environment::Point3>> ev_pair) {\n    std::vector<std::vector<double>> edges = ev_pair.first;\n    std::vector < data::environment::Point3 > vertices = ev_pair.second;\n\n    //std::cout << \"E = [\" << std::endl;\n\n    double no_edge = std::numeric_limits<double>::infinity();\n    uint32_t s = vertices.size();\n    for (uint32_t i = 0; i < s; i++) {\n        std::vector<double> from = edges[i];\n        double x1 = vertices[i].getX();\n        double y1 = vertices[i].getY();\n\n        for (uint32_t j = 0; j < i; j++) {\n            if (from[j] < no_edge) { //Cost of from-to < inf?\n                double x2 = vertices[j].getX();\n                double y2 = vertices[j].getY();\n                std::cout << x1 << \" \" << x2 << \" \" << y1 << \" \" << y2 << std::endl;\n            }\n        }\n    }\n    //std::cout << \"];\" << std::endl;\n\n    //std::cout << std::endl;\n\n    //std::cout << \"V = [\" << std::endl;\n    for (uint32_t i = 0; i < s; i++) {\n        double x = vertices[i].getX();\n        double y = vertices[i].getY();\n        std::cout << x << \" \" << y << std::endl;\n    }\n    std::cout << \"];\" << std::endl;\n}\n\n// =========================================================================//\n//                            Robot control                                 //\n// =========================================================================//\n\n// Collosion avoidance\n/*\n Return strue if there is an obstacle to avoid.\n */\nbool Navigation::detectCollision(int distance) {\n    if (USE_WHISKERS){\n        if (checkWhiskersDetection())\n            return true;\n    }\n\n    bool collision = false;\n\n    static int badCycles = 0;\n    static int veryBadCycles = 0;\n\n    static const int distanceLimit = 40;\n    static const int badCycleLimit = 2;\n\n    static const int distanceLimitHard = 20;\n    static const int badCycleLimitHard = 1;\n\n    if (distance < distanceLimit) {\n        badCycles++;\n\n        if (distance < distanceLimitHard)\n            veryBadCycles++;\n\n        collision = (badCycleLimitHard <= veryBadCycles || badCycleLimit <= badCycles);\n    } else {\n        badCycles = 0; // May not want to reset right away.\n        veryBadCycles = 0;\n    }\n\n    return collision;\n}\n\n// Wheel control\n\nvoid Navigation::leftWheel(int state, int speed) {\n    wheel(state, 1, speed);\n}\n\nvoid Navigation::rightWheel(int state, int speed) {\n    wheel(state, 2, speed);\n}\n\n/*\n Wheel state:\n 0:     off\n 1:     forward\n -1:    backward\n \n Wheel id:\n 1: Left\n 2: Right\n */\nvoid Navigation::wheel(int state, int id, int speed) {\n    if (id == 2) {\n        opendlv::proxy::ToggleRequest::ToggleState state30;\n        opendlv::proxy::ToggleRequest::ToggleState state31;\n        switch (state) {\n        case 1:\n            state30 = opendlv::proxy::ToggleRequest::On;\n            state31 = opendlv::proxy::ToggleRequest::Off;\n            break;\n        case 0:\n            state30 = opendlv::proxy::ToggleRequest::Off;\n            state31 = opendlv::proxy::ToggleRequest::Off;\n            break;\n        case -1:\n            state30 = opendlv::proxy::ToggleRequest::Off;\n            state31 = opendlv::proxy::ToggleRequest::On;\n            break;\n        }\n        opendlv::proxy::ToggleRequest request1(30, state30);\n        opendlv::proxy::ToggleRequest request2(31, state31);\n\n        odcore::data::Container c1(request1);\n        odcore::data::Container c2(request2);\n        c1.setSenderStamp(1);\n        c2.setSenderStamp(1);\n        getConference().send(c1);\n        getConference().send(c2);\n\n        // PWM\n        opendlv::proxy::PwmRequest request33(0, speed);\n        odcore::data::Container c33(request33);\n        c33.setSenderStamp(1);\n        getConference().send(c33);\n    } else if (id == 1) {\n        opendlv::proxy::ToggleRequest::ToggleState state51;\n        opendlv::proxy::ToggleRequest::ToggleState state60;\n        switch (state) {\n        case 1:\n            state51 = opendlv::proxy::ToggleRequest::On;\n            state60 = opendlv::proxy::ToggleRequest::Off;\n            break;\n        case 0:\n            state51 = opendlv::proxy::ToggleRequest::Off;\n            state60 = opendlv::proxy::ToggleRequest::Off;\n            break;\n        case -1:\n            state51 = opendlv::proxy::ToggleRequest::Off;\n            state60 = opendlv::proxy::ToggleRequest::On;\n            break;\n        }\n        opendlv::proxy::ToggleRequest request21(51, state51);\n        opendlv::proxy::ToggleRequest request22(60, state60);\n\n        odcore::data::Container c21(request21);\n        odcore::data::Container c22(request22);\n        c21.setSenderStamp(2);\n        c22.setSenderStamp(2);\n        getConference().send(c21);\n        getConference().send(c22);\n        opendlv::proxy::PwmRequest request33(0, speed);\n        odcore::data::Container c33(request33);\n        c33.setSenderStamp(2);\n        getConference().send(c33);\n    } else {\n        //std::cout << \"BAD WHEEL ID\" << std::endl;\n    }\n}\n\n// Actions\nvoid Navigation::left() {\n    leftWheel(-1, 32000);\n    rightWheel(1, 32300);\n}\n\nvoid Navigation::right() {\n    leftWheel(1, 32000);\n    rightWheel(-1, 32300);\n}\n\nvoid Navigation::back() {\n    leftWheel(-1, 35000);\n    rightWheel(-1, 35300);\n}\n\nvoid Navigation::forward() {\n    leftWheel(1, 35000);\n    rightWheel(1, 35100);\n}\n\nvoid Navigation::stop() {\n    leftWheel(0, 0);\n    rightWheel(0, 0);\n}\n\n//Returns true if any of the whiskers detect a collision\nbool Navigation::checkWhiskersDetection() {\n    return (m_gpioReadings[66] == 0 || m_gpioReadings[67] == 0);\n}\n\nstd::vector<int> Navigation::dijk(int startNodeIndex, std::vector<std::vector<double>> adj) {\n    int n = adj.size();\n    std::vector<double> dist(n);\n    std::vector<int> pre(n);\n    std::vector<bool> vis(n);\n    \n    for(uint32_t i = 0; i != pre.size(); i++)\n        pre[i] = -(i+1);\n        \n    // Set all distances to infinity except start\n    for (int i = 0; i < n; ++i) {\n        dist[i] = std::numeric_limits<double>::infinity();\n        vis[i] = false;\n    }\n\n    // Set the start node as visited\n    dist[startNodeIndex] = 0;\n    int currentNodeIndex = startNodeIndex;\n    int nextNodeIndex; // = currentNodeIndex; //Problem: this is never updated below.\n\n    // Find nearest neighbour\n    for (int i = 0; i < n; i++) {\n        ////std::cout << \"i = \" << i << std::endl;\n        vis[currentNodeIndex] = true;\n        double minimumDistance = 10000000;\n        for (int j = 0; j < n; j++) {\n            ////std::cout << \"\\tj = \" << j << std::endl;\n            ////std::cout << \"\\tadj[currentNodeIndex][j] = \" << adj[currentNodeIndex][j] << std::endl;\n            if (!vis[j] && adj[currentNodeIndex][j] < std::numeric_limits<double>::infinity()) {\n                if (dist[currentNodeIndex] + adj[currentNodeIndex][j] < dist[j]) {\n                    dist[j] = dist[currentNodeIndex] + adj[currentNodeIndex][j];\n                    pre[j] = currentNodeIndex;\n                  \n                }\n            }\n        }\n        \n        for (int j = 0; j < n; j++) {\n            if (dist[j] < minimumDistance && !vis[j]) {\n                nextNodeIndex = j;\n                minimumDistance = dist[j];\n            }\n        }\n        \n        currentNodeIndex = nextNodeIndex;\n    }\n    \n    return pre;\n}\n\nstd::vector<int> Navigation::getNodeSequence(int startNode, int endNode, std::vector<int> pre) {\n\n    int counter = 0;\n    int nNodes = pre.size();\n    std::vector<int> nodeSequence(1);\n    nodeSequence[0] = endNode;\n    int nextNode = pre[endNode];\n    for(std::vector<int>::iterator it = pre.begin(); it != pre.end(); ++it){\n                           \n                            //std::cout << *it << \" \" ;\n                            //data::environment::Point3 v = m_vert[*it];\n                            ////std::cout << v.getX() << \" \";\n                            ////std::cout << v.getY() << std::endl;\n                            }\n    //std::cout << std::endl;\n    //std::cout << \"(from, to) = (\" << startNode << \", \" << endNode << \")\" << std::endl;\n    \n    while (nextNode != startNode && counter < nNodes) { //Case node has no pre is not handled\n        counter++;\n        //nodeSequence[counter] = nextNode;\n        nodeSequence.push_back(nextNode);\n        \n        if (nextNode < 0 || nextNode >= nNodes) {\n            std::vector<int> emptyVector;\n            return emptyVector;\n        }\n        \n        nextNode = pre[nextNode];\n        //std::cout << \"nextNode = \" << nextNode << std::endl;\n    }\n\n\n                        //std::cout << \"(x, y, m_yaw) = (\" << m_posX << \", \" << m_posY << \", \" << m_yaw << \")\" << std::endl;\n                        //std::cout << \"TARGET: (x, y, m_targetHeading) = (\" << m_targetPosition.getX() << \", \" << m_targetPosition.getY() << \", \" << m_targetHeading << \")\" << std::endl;\n\n    if (counter == nNodes) {\n        //Invalid answer, there is no path\n        std::vector<int> emptyVector;\n        ////std::cout << \"return emptyVector\" << std::endl; \n        //std::cout << \"FAILED TO FIND PATH\" << std::endl; \n        //std::cout << \"(from, to) = (\" << startNode << \", \" << endNode << \")\" << std::endl;\n        //std::cout << \"FAILED TO FIND PATH\" << std::endl; \n        //std::cout << \"(from, to) = (\" << startNode << \", \" << endNode << \")\" << std::endl;\n        return emptyVector;\n    } else {\n        counter++;\n        nodeSequence.push_back(startNode);\n        //nodeSequence[counter] = startNode;\n        std::reverse(nodeSequence.begin(), nodeSequence.end());\n        ////std::cout << \"return nodeSequence\" << std::endl;\n        return nodeSequence;\n    }\n}\n\n/*\n This method receives messages from all other modules (in the same conference\n id, cid). Here, the messages AnalogReading and ToggleReading is received\n from the modules interfacing to the hardware.\n */\nvoid Navigation::nextContainer(odcore::data::Container & a_c) {\n    odcore::base::Lock l(m_mutex);\n\n    int32_t dataType = a_c.getDataType();\n    if (dataType == opendlv::proxy::AnalogReading::ID()) {\n        opendlv::proxy::AnalogReading reading = a_c.getData<opendlv::proxy::AnalogReading>();\n\n        uint16_t pin = reading.getPin();\n        float voltage = reading.getVoltage();\n\n        m_analogReadings[pin] = voltage; // Save the input to the class global map.\n\n        ////std::cout << \"[\" << getName()\n        //          << \"] Received an AnalogReading: \" << reading.toString() << \".\"\n        //          << std::endl;\n    } else if (dataType == opendlv::proxy::ToggleReading::ID()) {\n        opendlv::proxy::ToggleReading reading = a_c.getData<opendlv::proxy::ToggleReading>();\n\n        uint16_t pin = reading.getPin();\n        bool state = (reading.getState() == opendlv::proxy::ToggleReading::On);\n        m_gpioReadings[pin] = state; // Save the state to the class global map.\n\n        ////std::cout << \"[\" << getName()\n        //          << \"] Received a ToggleReading: \" << reading.toString() << \".\"\n        //          << std::endl;\n    } else if (dataType == opendlv::model::State::ID()) {\n        opendlv::model::State state = a_c.getData<opendlv::model::State>();\n\n        m_posX = static_cast<double>(state.getPosition().getX());\n        m_posY = static_cast<double>(state.getPosition().getY());\n        m_yaw = static_cast<double>(state.getAngularDisplacement().getZ());\n\n        m_currentPosition.setX(m_posX);\n        m_currentPosition.setY(m_posY);\n        m_pointsOfInterest[m_pointsOfInterest.size()-1] = m_currentPosition;\n        \n        m_lastLpsSignal = m_now;\n        LPS_DOWN = false;\n\n        ////std::cout << \"LPS: (x, y, yaw) = (\" << m_posX << \", \" << m_posY << \" yaw \" << m_yaw << \").\" << std::endl;\n    } else if (dataType == opendlv::proxy::ProximityReading::ID()) {\n        opendlv::proxy::ProximityReading reading = a_c.getData<opendlv::proxy::ProximityReading>();\n\n        m_pingDistance = reading.getProximity();\n        ////std::cout << \"m_pingDistance: \" << m_pingDistance << std::endl;\n    }\n}\n\nstd::vector<data::environment::Point3> Navigation::ReadPointString(std::string const &a_pointsString) const {\n    std::vector < data::environment::Point3 > points;\n    std::vector < std::string > pointStringVector = odcore::strings::StringToolbox::split(a_pointsString, ';');\n    for (auto pointString : pointStringVector) {\n        std::vector < std::string > coordinateVector = odcore::strings::StringToolbox::split(pointString, ',');\n        if (coordinateVector.size() == 2) {\n            double x = std::stod(coordinateVector[0]);\n            double y = std::stod(coordinateVector[1]);\n            double z = 0.0;\n            points.push_back(data::environment::Point3(x, y, z));\n        }\n    }\n    return points;\n}\n}\n}\n}\n"
    },
    "done": false
  }
]