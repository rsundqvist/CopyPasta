[
  {
    "files": {
      "StudentFileViewerController.java": "package gui.feedback;\n\nimport gui.Tools;\nimport javafx.event.Event;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.CheckBox;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.TabPane;\nimport javafx.scene.control.ToggleButton;\nimport javafx.scene.input.DragEvent;\nimport javafx.scene.input.Dragboard;\nimport javafx.scene.input.TransferMode;\nimport javafx.stage.FileChooser;\nimport javafx.util.Pair;\nimport model.Feedback;\nimport model.IO;\n\nimport java.io.File;\nimport java.util.Map;\n\n/**\n * Created by Richard Sundqvist on 26/03/2017.\n */\npublic class StudentFileViewerController {\n    @FXML\n    private Label fileLabel = null;\n    @FXML\n    private TabPane sourceTabs = null;\n    @FXML\n    private Label copiedLabel = null;\n\n    private FileTab currentFileTab = null;\n    private boolean feedbackLine = true, feedbackColumn = false;\n    private final FileFeedbackListener listener;\n    private final Feedback feedback;\n    private boolean editable = false;\n\n    public StudentFileViewerController (FileFeedbackListener listener, Feedback feedback) {\n        this.listener = listener;\n        this.feedback = feedback;\n    }\n\n    @FXML\n    private void initialize () {\n        copiedLabel.setOpacity(0);\n        sourceTabs.getSelectionModel().selectedItemProperty().addListener(event -> {\n            currentFileTab = (FileTab) sourceTabs.getSelectionModel().getSelectedItem();\n\n            if (currentFileTab == null)\n                fileLabel.setText(\"Drag and drop to add files!\");\n            else\n                fileLabel.setText(currentFileTab.getText());\n        });\n\n        Map<String, String> files = feedback.getFiles();\n        for (String key : files.keySet())\n            sourceTabs.getTabs().add(new FileTab(key, files.get(key)));\n    }\n\n    public void onFeedback () {\n        if (currentFileTab != null) {\n            int line = getCaretLine();\n            int column = getCaretColumn();\n            int pos = currentFileTab.getCaretPosition();\n            listener.feedbackAt(currentFileTab.getText(), line, column, pos);\n        }\n    }\n\n    public void toggleEditable (Event e) {\n\n        if (!sourceTabs.getTabs().isEmpty()) {\n            ToggleButton toggleButton = (ToggleButton) e.getSource();\n            editable = toggleButton.isSelected();\n\n            if (editable) {\n                toggleButton.setText(\"Save\");\n                sourceTabs.getTabs().forEach(tab -> ((FileTab) tab).setEditable(true));\n            } else {\n                toggleButton.setText(\"Edit\");\n                sourceTabs.getTabs().forEach(tab -> {\n                    FileTab fileTab = (FileTab) tab;\n                    feedback.addFile(fileTab.getText(), fileTab.getCodeAreaContent());\n                    fileTab.setEditable(false);\n                });\n            }\n        }\n    }\n\n    public int getCaretLine () {\n        return feedbackLine ? currentFileTab.getCaretLine() : -1;\n    }\n\n    public int getCaretColumn () {\n        return feedbackColumn ? currentFileTab.getCaretColumn() : -1;\n    }\n\n    public void toggleFeedbackLine (Event event) {\n        feedbackLine = ((CheckBox) event.getSource()).isSelected();\n    }\n\n    public void toggleFeedbackColumn (Event event) {\n        feedbackColumn = ((CheckBox) event.getSource()).isSelected();\n    }\n\n    public void onDragDropped (DragEvent event) {\n        Dragboard db = event.getDragboard();\n        boolean success = false;\n        if (db.hasFiles()) {\n            success = true;\n\n            for (File file : db.getFiles()) {\n                String content = IO.getFileAsString(file);\n                addFile(file.getName(), content);\n            }\n        }\n        event.setDropCompleted(success);\n        event.consume();\n    }\n\n    public void onDragOver (DragEvent event) {\n        Dragboard db = event.getDragboard();\n\n        if (db.hasFiles())\n            event.acceptTransferModes(TransferMode.COPY);\n        else\n            event.consume();\n    }\n\n    public void onAdd () {\n        FileChooser fileChooser = new FileChooser();\n        File file = fileChooser.showOpenDialog(null);\n        if (file != null)\n            addFile(file.getName(), IO.getFileAsString(file));\n    }\n\n    public void onDelete () {\n        if (currentFileTab != null) {\n            feedback.removeFile(currentFileTab.getFileName());\n            sourceTabs.getTabs().remove(currentFileTab);\n        }\n    }\n\n    public void addFile (String fileName, String content) {\n        feedback.addFile(fileName, content);\n        FileTab fileTab = new FileTab(fileName, content);\n        fileTab.setEditable(editable);\n        sourceTabs.getTabs().add(fileTab);\n    }\n\n    public Pair<String, Integer> getCurrentFileAndCaretPos () {\n        String file = currentFileTab == null ? null : currentFileTab.getText();\n        int pos = currentFileTab.getCaretPosition();\n        return new Pair(file, pos);\n    }\n\n    public FileTab getCurrentFileTab () {\n        return currentFileTab;\n    }\n\n    public interface FileFeedbackListener {\n        void feedbackAt (String file, int caretLine, int caretColumn, int caretPosition);\n\n        void feedbackAt (String file, String content, int caretLine, int caretColumn, int caretPosition);\n    }\n\n    public void flashCopiedlabel () {\n        Tools.flashNode(copiedLabel);\n    }\n}\n",
      "JavaCodeArea.java": "package gui.feedback;\n\nimport org.fxmisc.richtext.CodeArea;\nimport org.fxmisc.richtext.LineNumberFactory;\nimport org.fxmisc.richtext.ViewActions;\nimport org.fxmisc.richtext.model.StyleSpans;\nimport org.fxmisc.richtext.model.StyleSpansBuilder;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Created by Richard Sundqvist on 17/04/2017.\n */\npublic class JavaCodeArea extends CodeArea {\n\n    // region strings\n    private static final String[] KEYWORDS = new String[]{\"abstract\", \"assert\", \"boolean\", \"break\", \"byte\", \"case\", \"catch\", \"char\", \"class\", \"const\", \"continue\", \"default\", \"do\", \"double\", \"else\", \"enum\", \"extends\", \"final\", \"finally\", \"float\", \"for\", \"goto\", \"if\", \"implements\", \"import\", \"instanceof\", \"int\", \"interface\", \"long\", \"native\", \"new\", \"package\", \"private\", \"protected\", \"public\", \"return\", \"short\", \"static\", \"strictfp\", \"super\", \"switch\", \"synchronized\", \"this\", \"throw\", \"throws\", \"transient\", \"try\", \"void\", \"volatile\", \"while\", \"null\", \"->\"};\n\n    private static final String KEYWORD_PATTERN = \"\\\\b(\" + String.join(\"|\", KEYWORDS) + \")\\\\b\";\n    private static final String PAREN_PATTERN = \"\\\\(|\\\\)\";\n    private static final String BRACE_PATTERN = \"\\\\{|\\\\}\";\n    private static final String BRACKET_PATTERN = \"\\\\[|\\\\]\";\n    private static final String SEMICOLON_PATTERN = \"\\\\;\";\n    private static final String STRING_PATTERN = \"\\\"([^\\\"\\\\\\\\]|\\\\\\\\.)*\\\"\";\n    private static final String COMMENT_PATTERN = \"//[^\\n]*\" + \"|\" + \"/\\\\*(.|\\\\R)*?\\\\*/\";\n\n    private static final Pattern PATTERN = Pattern.compile(\"(?<KEYWORD>\" + KEYWORD_PATTERN + \")\" + \"|(?<PAREN>\" + PAREN_PATTERN + \")\" + \"|(?<BRACE>\" + BRACE_PATTERN + \")\" + \"|(?<BRACKET>\" + BRACKET_PATTERN + \")\" + \"|(?<SEMICOLON>\" + SEMICOLON_PATTERN + \")\" + \"|(?<STRING>\" + STRING_PATTERN + \")\" + \"|(?<COMMENT>\" + COMMENT_PATTERN + \")\");\n    // endregion\n\n    public JavaCodeArea () {\n        this(null);\n    }\n\n    public JavaCodeArea (String initialContent) {\n        setStyle(\"-fx-font-family: consolas; -fx-font-size: 11pt;-fx-background-color: #dddddd;\");\n        setShowCaret(ViewActions.CaretVisibility.ON);\n        setParagraphGraphicFactory(LineNumberFactory.get(this));\n\n        richChanges().filter(ch -> !ch.getInserted().equals(ch.getRemoved())).subscribe(change -> {\n            setStyleSpans(0, computeHighlighting(getText()));\n        });\n        if (initialContent != null)\n            replaceText(0, 0, initialContent);\n    }\n\n    public void setText (String s) {\n        if (getText() != null && s != null && s.length() > 0)\n            replaceText(0, getText().length(), s);\n    }\n\n    // @formatter:off\n    private static StyleSpans<Collection<String>> computeHighlighting(String text) {\n        Matcher matcher = PATTERN.matcher(text);\n        int lastKwEnd = 0;\n        StyleSpansBuilder<Collection<String>> spansBuilder = new StyleSpansBuilder<>();\n        while (matcher.find()) {\n            String styleClass =\n                    matcher.group(\"KEYWORD\") != null\n                            ? \"keyword\"\n                            : matcher.group(\"PAREN\") != null\n                                    ? \"paren\"\n                                    : matcher.group(\"BRACE\") != null\n                                            ? \"brace\"\n                                            : matcher.group(\"BRACKET\") != null\n                                                    ? \"bracket\"\n                                                    : matcher.group(\"SEMICOLON\") != null\n                                                            ? \"semicolon\"\n                                                            : matcher.group(\"STRING\") != null\n                                                                    ? \"string\"\n                                                                    : matcher.group(\"COMMENT\")\n                                                                                    != null\n                                                                            ? \"comment\"\n                                                                            : null; /* never happens */\n            assert styleClass != null;\n            spansBuilder.add(Collections.emptyList(), matcher.start() - lastKwEnd);\n            spansBuilder.add(Collections.singleton(styleClass), matcher.end() - matcher.start());\n            lastKwEnd = matcher.end();\n        }\n        spansBuilder.add(Collections.emptyList(), text.length() - lastKwEnd);\n        return spansBuilder.create();\n    }\n    // @formatter:on\n}\n",
      "FileTab.java": "package gui.feedback;\n\nimport javafx.scene.control.Tab;\nimport org.fxmisc.flowless.VirtualizedScrollPane;\nimport org.fxmisc.richtext.CodeArea;\nimport org.fxmisc.richtext.model.TwoDimensional;\n\n/**\n * Created by Richard Sundqvist on 12/04/2017.\n */\npublic class FileTab extends Tab {\n\n    private final CodeArea codeArea;\n    private final int firstNumber; // Set to 1 to set the first line to 1.\n\n    public FileTab (String fileName, String content) {\n        this(fileName, content, false);\n    }\n\n    /**\n     * @param fileName Name of the file.\n     * @param content Content of the file\n     * @param startFromZero If {@code true}, row count begins at zero.\n     */\n    public FileTab (String fileName, String content, boolean startFromZero) {\n        firstNumber = startFromZero ? 0 : 1;\n\n        setText(fileName);\n        setClosable(false);\n\n        codeArea = new JavaCodeArea(content);\n        codeArea.setEditable(false);\n        setContent(new VirtualizedScrollPane<>(codeArea));\n    }\n\n    public String getFileName () {\n        return getText();\n    }\n\n    public int getCaretLine () {\n        int offset = codeArea.getCaretPosition();\n        TwoDimensional.Position pos = codeArea.offsetToPosition(offset, TwoDimensional.Bias.Forward);\n        return pos.getMajor() + firstNumber;\n    }\n\n    public String getCodeAreaContent () {\n        return codeArea.getText();\n    }\n\n    public int getCaretColumn () {\n        int offset = codeArea.getCaretPosition();\n        TwoDimensional.Position pos = codeArea.offsetToPosition(offset, TwoDimensional.Bias.Forward);\n        return pos.getMinor() + firstNumber;\n    }\n\n    public int getCaretPosition () {\n        return codeArea.getCaretPosition();\n    }\n\n    public void setEditable (boolean value) {\n        codeArea.setEditable(value);\n    }\n}\n",
      "StudentFileViewer.java": "package gui.feedback;\n\n/**\n * Created by Richard Sundqvist on 26/03/2017.\n */\n\nimport javafx.fxml.FXMLLoader;\nimport javafx.scene.layout.BorderPane;\nimport model.Feedback;\nimport model.IO;\n\n/**\n * Created by Richard Sundqvist on 26/03/2017.\n */\npublic class StudentFileViewer extends BorderPane {\n    private StudentFileViewerController controller;\n\n    public StudentFileViewer (StudentFileViewerController.FileFeedbackListener listener, Feedback feedback) {\n\n        FXMLLoader fxmlLoader = new FXMLLoader(getClass().getResource(\"/fxml/studentFileViewer.fxml\"));\n        fxmlLoader.setController(new StudentFileViewerController(listener, feedback));\n        BorderPane root;\n        try {\n            root = fxmlLoader.load();\n            setCenter(root);\n        } catch (Exception e) {\n            IO.showExceptionAlert(e);\n            e.printStackTrace();\n        }\n\n        maxWidth(-1);\n        maxHeight(-1);\n        setStyle(\"-fx-background: rgb(225, 228, 203);\");\n        // setStyle(\"-fx-background: #123456;\");\n        controller = fxmlLoader.getController();\n    }\n\n    public void addFile (String fileName, String content) {\n        controller.addFile(fileName, content);\n    }\n\n    public StudentFileViewerController getController () {\n        return controller;\n    }\n}\n",
      "FeedbackViewController.java": "package gui.feedback;\n\nimport gui.Tools;\nimport javafx.animation.KeyFrame;\nimport javafx.animation.Timeline;\nimport javafx.event.Event;\nimport javafx.fxml.FXML;\nimport javafx.scene.control.Alert;\nimport javafx.scene.control.ButtonType;\nimport javafx.scene.control.CheckBox;\nimport javafx.scene.control.ContextMenu;\nimport javafx.scene.control.Label;\nimport javafx.scene.control.ListView;\nimport javafx.scene.control.MenuItem;\nimport javafx.scene.control.ProgressBar;\nimport javafx.scene.control.SelectionMode;\nimport javafx.scene.control.SeparatorMenuItem;\nimport javafx.scene.control.Tab;\nimport javafx.scene.control.TabPane;\nimport javafx.scene.control.TextArea;\nimport javafx.scene.control.TextField;\nimport javafx.scene.control.TextInputDialog;\nimport javafx.scene.control.TitledPane;\nimport javafx.scene.input.KeyCode;\nimport javafx.scene.input.KeyCodeCombination;\nimport javafx.scene.input.KeyCombination;\nimport javafx.scene.input.KeyEvent;\nimport javafx.scene.input.MouseButton;\nimport javafx.scene.input.MouseEvent;\nimport javafx.scene.layout.HBox;\nimport javafx.scene.layout.Priority;\nimport javafx.util.Duration;\nimport model.Feedback;\nimport model.FeedbackManager;\nimport model.IO;\nimport model.Pasta;\n\nimport java.io.File;\nimport java.util.ArrayList;\nimport java.util.List;\nimport java.util.Optional;\n\n/**\n * Created by Richard Sundqvist on 19/02/2017.\n */\npublic class FeedbackViewController {\n\n    private static final int SUPPRESS_CONFIRMATION_DURATION = 90; // in seconds\n    // region Field\n    // ================================================================================= //\n    // Field\n    // ================================================================================= //\n    @FXML\n    private Tab groupTab, setupTab, progressTab;\n    @FXML\n    private TextField studentGroupField, assignmentField;\n    @FXML\n    private Label progressLabel;\n    @FXML\n    private TabPane feedbackTabPane, rootTabPane;\n    @FXML\n    private TextArea teacherField, templateTextArea, templateHeaderTextArea, templateFooterTextArea;\n\n    @FXML\n    /** Container for the actual feedback tabs. */ private ListView feedbackTabListView;\n\n    private FeedbackManager feedbackManager = new FeedbackManager();\n    private List<GroupTab> groupTabs = new ArrayList<>();\n    // endregion\n    private boolean hideDoneItems;\n    @FXML\n    private Label numFeedback, numDone, numNotDone;\n    @FXML\n    private ProgressBar progressBar;\n    @FXML\n    private ListView doneListView, notDoneListView;\n    private boolean suppressClearDoneDialog = false;\n    private boolean suppressClearNotDoneDialog = false;\n\n    public void updateFeedbackTabLockStatus () {\n        boolean empty = feedbackTabPane.getTabs().isEmpty();\n        groupTab.setDisable(empty);\n        if (empty)\n            rootTabPane.getSelectionModel().select(setupTab);\n    }\n\n    public void createFeedbackItems (List<String> groups) {\n        // Groups exist already? Modified?\n\n        updateTemplate(); // make sure template is up-to-date for isContentModified\n        List<Feedback> existing = feedbackManager.getByGroup(groups);\n        List<Feedback> existingModified = feedbackManager.isContentModified(existing);\n        List<Feedback> existingUnmodified = new ArrayList<>(existing);\n        existingUnmodified.removeAll(existingModified);\n\n        int numClash = existing.size();\n        if (numClash > 0) {\n            String contentText = \"Groups with modified content: \\n\\t\" + FeedbackManager.getGroups(existingModified) + \"\\n\" + \"Groups without modified content (unchanged): \\n\\t\" + FeedbackManager.getGroups(existingUnmodified);\n\n            ButtonType replaceAll = new ButtonType(\"Overwrite All (\" + numClash + \")\");\n            ButtonType replaceUnchanged = new ButtonType(\"Overwrite Unchanged (\" + existingUnmodified.size() + \")\");\n\n            Alert alert = new Alert(Alert.AlertType.CONFIRMATION, contentText, replaceAll, replaceUnchanged, ButtonType.CANCEL);\n            alert.setHeaderText(\"Overwrite existing groups?\");\n\n            Optional<ButtonType> result = alert.showAndWait();\n            if (!result.isPresent() || result.get() == ButtonType.CANCEL)\n                return;\n\n            if (result.get() == replaceAll) {\n                feedbackManager.removeFeedback(existing);\n                removeFeedbackTabs(existing);\n            } else if (result.get() == replaceUnchanged) {\n                feedbackManager.removeFeedback(existingUnmodified);\n                removeFeedbackTabs(existingUnmodified);\n            } else {\n                throw new IllegalStateException(\"Unhandled case: \" + result.get());\n            }\n        }\n        List<Feedback> newFeedbackList = feedbackManager.generateFeedback(groups);\n\n        if (newFeedbackList != null) {\n            for (Feedback feedback : newFeedbackList)\n                createFeedbackTab(feedback);\n\n            if (newFeedbackList.size() > 1)\n                rootTabPane.getSelectionModel().select(groupTab);\n        }\n\n        updateFeedbackTabLockStatus();\n    }\n\n    /**\n     * FXML onAction for \"Create Feedback\" button.\n     */\n    public void createFeedbackItems () {\n        String str = studentGroupField.getText();\n        List<String> groups = FeedbackManager.parseGroupString(str);\n        createFeedbackItems(groups);\n    }\n\n    private void removeFeedbackTabs (List<Feedback> feedbackList) {\n        List<GroupTab> removedGroupTabs = getFeedbackTabs(feedbackList);\n\n        feedbackTabListView.getItems().removeAll(removedGroupTabs);\n        feedbackTabPane.getTabs().removeAll(removedGroupTabs);\n        groupTabs.removeAll(removedGroupTabs);\n        updateFeedbackTabLockStatus();\n    }\n\n    private List<GroupTab> getFeedbackTabs (List<Feedback> feedbackList) {\n        List<GroupTab> removedGroupTabs = new ArrayList<>();\n\n        for (GroupTab tab : groupTabs)\n            if (feedbackList.contains(tab.getFeedback()))\n                removedGroupTabs.add(tab);\n        return removedGroupTabs;\n    }\n\n    private void updateTemplate () {\n        Feedback template = feedbackManager.getTemplate();\n        template.setContent(templateTextArea.getText());\n        template.setHeader(templateHeaderTextArea.getText());\n        template.setFooter(templateFooterTextArea.getText());\n        template.setSignature(teacherField.getText());\n        template.setAssignment(getAssignment());\n        feedbackManager.setTemplate(template);\n    }\n\n    private void createFeedbackTab (Feedback feedback) {\n        GroupTab tab = new GroupTab(feedback);\n        tab.setContextMenu(createFeedbackTabContextMenu(tab));\n        tab.setOnClosed(event -> updateFeedbackTabLockStatus());\n        if (!feedback.isDone())\n            feedbackTabPane.getTabs().add(tab);\n        feedbackTabListView.getItems().add(tab);\n        groupTabs.add(tab);\n    }\n\n    private ContextMenu createFeedbackTabContextMenu (GroupTab tab) {\n        ContextMenu contextMenu = new ContextMenu();\n\n        MenuItem changeGroup = new MenuItem(\"Change group\");\n        changeGroup.setOnAction(event -> changeFeedbackGroup(tab));\n\n        MenuItem toggleDone = new MenuItem(\"Toggle done\");\n        toggleDone.setAccelerator(new KeyCodeCombination(KeyCode.D, KeyCombination.CONTROL_DOWN));\n        toggleDone.setOnAction(event -> toggleDone(tab, true));\n\n        MenuItem preview = new MenuItem(\"Preview\");\n        preview.setOnAction(event -> preview(tab));\n\n        MenuItem exportTxt = new MenuItem(\"Export .txt\");\n        exportTxt.setOnAction(event -> exportFeedbackAsTxt(tab.getFeedback()));\n\n        MenuItem exportJson = new MenuItem(\"Export .json\");\n        exportJson.setOnAction(event -> exportFeedbackAsJson(tab.getFeedback()));\n\n        MenuItem delete = new MenuItem(\"Delete\");\n        delete.setOnAction(event -> deleteFeedback(tab));\n\n        contextMenu.getItems().addAll(changeGroup, toggleDone, preview, new SeparatorMenuItem(), exportTxt, exportJson, new SeparatorMenuItem(), delete);\n\n        return contextMenu;\n    }\n\n    public void exportTemplate () {\n        updateTemplate();\n        IO.exportSingleFeedbackAsJson(null, feedbackManager.getTemplate());\n    }\n\n    public void importTemplate () {\n        File file = IO.showJSONOpenDialog();\n        Feedback template = IO.importFeedbackSingle(file);\n        setFeedbackTemplate(template);\n    }\n\n    public void exportAllFeedback () {\n        exportFeedback(extractFeedback(false), true, true);\n    }\n\n    public void exportFeedbackAsTxt (Feedback feedback) {\n        List<Feedback> feedbackList = new ArrayList<>(1);\n        feedbackList.add(feedback);\n        exportFeedback(feedbackList, true, false);\n    }\n\n    public void exportFeedbackAsJson (Feedback feedback) {\n        List<Feedback> feedbackList = new ArrayList<>(1);\n        feedbackList.add(feedback);\n        exportFeedback(feedbackList, false, true);\n    }\n\n    public void exportFeedbackAsTxt () {\n        exportFeedback(extractFeedback(true), true, false);\n    }\n\n    public void exportFeedbackAsJson () {\n        exportFeedback(extractFeedback(true), false, true);\n    }\n\n    private boolean exportFeedback (List<Feedback> feedbackList, boolean asTxt, boolean asJson) {\n        if (feedbackList == null || feedbackList.isEmpty() || !(asTxt || asJson))\n            return false;\n\n        updateTemplate();\n        feedbackManager.updateFeedback();\n\n        if (checkManualTags(feedbackList))\n            return false;\n\n        boolean exportSuccessful;\n        if (asTxt && asJson) {\n            exportSuccessful = IO.exportFeedbackAsTxtAndJson(null, feedbackList);\n        } else if (feedbackList.size() == 1) { // Only one item\n            Feedback feedback = feedbackList.get(0);\n            String initialFileName = feedback.getGroup();\n            File file = IO.showSaveDialog(null, initialFileName, asTxt ? \"txt\" : \"json\");\n\n            if (asTxt)\n                exportSuccessful = IO.printStringToFile(feedback.getStylizedContent(), file);\n            else\n                exportSuccessful = IO.exportFeedbackAsJson(feedbackList, file);\n        } else {\n            if (asTxt)\n                exportSuccessful = IO.exportFeedbackAsTxt(null, feedbackList);\n            else\n                exportSuccessful = IO.exportFeedbackAsJson(null, feedbackList);\n        }\n\n        return exportSuccessful;\n    }\n\n    /**\n     * Returns true if the user wishes to abort.\n     */\n    public boolean checkManualTags (List<Feedback> feedbackList) {\n        List<Feedback> badFeedbackList = Feedback.checkManual(feedbackList);\n\n        if (badFeedbackList.isEmpty())\n            return false;\n\n        List<String> groups = FeedbackManager.getGroups(badFeedbackList);\n        Alert alert = new Alert(Alert.AlertType.INFORMATION);\n        alert.getButtonTypes().clear();\n        alert.getButtonTypes().addAll(ButtonType.YES, ButtonType.NO);\n        alert.setTitle(\"Incomplete items found\");\n        alert.setHeaderText(\"Found \" + badFeedbackList.size() + \" incomplete items (of \" + feedbackList.size() + \" items total)\");\n        alert.setContentText(\"It looks like you're trying to export items with the \" + Feedback.MANUAL + \" tag present, \" + \"indicating that some items have content not meant for the student. Rectify before exporting?\");\n\n        // Content tags\n        Label contentLabel = new Label(\"Groups: \");\n        contentLabel.setMaxHeight(Double.MAX_VALUE);\n\n        String badGroups = groups.toString();\n        badGroups = badGroups.substring(1, badGroups.length() - 1);\n\n        TextField badGroupsTextField = new TextField(badGroups);\n        badGroupsTextField.setEditable(false);\n        badGroupsTextField.setMaxWidth(Double.MAX_VALUE);\n        HBox.setHgrow(badGroupsTextField, Priority.ALWAYS);\n\n        HBox contentTagsHBox = new HBox();\n        contentTagsHBox.getChildren().addAll(contentLabel, badGroupsTextField);\n        HBox.setHgrow(badGroupsTextField, Priority.ALWAYS);\n\n        // Set expandable Exception into the dialog pane.\n        alert.getDialogPane().setExpandableContent(contentTagsHBox);\n        alert.getDialogPane().setExpanded(true);\n\n        Optional<ButtonType> result = alert.showAndWait();\n\n        if (!result.isPresent() || result.get() != ButtonType.NO) { // Default to assuming user wants to fix content.\n            List<GroupTab> badGroupTabs = getFeedbackTabs(badFeedbackList);\n            for (GroupTab groupTab : badGroupTabs) {\n                groupTab.getFeedback().setDone(true);\n                toggleDone(groupTab, false);\n            }\n            feedbackTabPane.getTabs().removeAll(badGroupTabs);\n            feedbackTabPane.getTabs().addAll(0, badGroupTabs);\n            feedbackTabPane.getSelectionModel().select(0);\n            rootTabPane.getSelectionModel().select(groupTab);\n            updateFeedbackTabLockStatus();\n            return true;\n        }\n\n        return false;\n    }\n\n    /**\n     * Extract feedback from {@link #feedbackTabListView}, or copy the list from the manager.\n     *\n     * @param selectedOnly If {@true}, extract selection only. Otherwise extract everything in them\n     * manager.\n     * @return A list of feedback.\n     */\n    private List<Feedback> extractFeedback (boolean selectedOnly) {\n        List<Feedback> feedbackList = new ArrayList<>();\n\n        if (selectedOnly) {\n            List<GroupTab> tabs = feedbackTabListView.getSelectionModel().getSelectedItems();\n            for (GroupTab tab : tabs)\n                feedbackList.add(tab.getFeedback());\n        } else {\n            feedbackList.addAll(feedbackManager.getFeedbackList());\n        }\n\n        return feedbackList;\n    }\n\n    public void deleteFeedback () {\n        if (!feedbackTabListView.isFocused())\n            return;\n\n        List<Object> selectedItems = new ArrayList<>(feedbackTabListView.getSelectionModel().getSelectedItems());\n        // Must use copy, feedbackTabListView.getItems().remove() calls will cause issues otherwise.\n\n        int numberOfItems = selectedItems.size();\n        if (numberOfItems > 1 && !Tools.confirmDelete(numberOfItems))\n            return;\n\n        if (numberOfItems == 1) {\n            GroupTab tab = ((GroupTab) selectedItems.get(0));\n            updateTemplate();\n            if (feedbackManager.isContentModified(tab.getFeedback())) {\n\n                String contentText = \"The content of this feedback seems to have been modified.\";\n                Alert alert = new Alert(Alert.AlertType.CONFIRMATION, contentText, ButtonType.OK, ButtonType.CANCEL);\n\n                alert.setHeaderText(\"Really delete feedback for group \\\"\" + tab.getFeedback().getGroup() + \"\\\"?\");\n\n                Optional<ButtonType> result = alert.showAndWait();\n                if (!result.isPresent() || result.get() != ButtonType.OK)\n                    return;\n            }\n        }\n\n        for (Object o : selectedItems)\n            deleteFeedback((GroupTab) o);\n\n        updateFeedbackTabLockStatus();\n    }\n\n    private void deleteFeedback (GroupTab tab) {\n        if (tab == null)\n            return;\n\n        feedbackTabPane.getTabs().remove(tab);\n        feedbackTabListView.getItems().remove(tab);\n        groupTabs.remove(tab);\n        feedbackManager.removeFeedback(tab.getFeedback());\n        updateFeedbackTabLockStatus();\n    }\n\n    public void importFeedback () {\n        List<Feedback> feedbackList = feedbackManager.importFeedback();\n\n        if (feedbackList != null)\n            updateAfterFeedbackImport(feedbackList);\n    }\n\n    /**\n     * Import feedback.\n     *\n     * @param feedbackList The feedback to import.\n     * @param replaceAll if {@code true}, old feedback is cleared.\n     */\n    public void importFeedbackAddTemplateContent (List<Feedback> feedbackList, boolean replaceAll) {\n        updateTemplate();\n        if (replaceAll)\n            clearFeedback();\n\n        List<Feedback> newFeedbackList = feedbackManager.importFeedback(feedbackList, true);\n        updateAfterFeedbackImport(newFeedbackList);\n    }\n\n    private void updateAfterFeedbackImport (List<Feedback> feedbackList) {\n        for (Feedback feedback : feedbackList)\n            createFeedbackTab(feedback);\n\n        rootTabPane.getSelectionModel().select(groupTab);\n        updateFeedbackTabLockStatus();\n    }\n\n    public void initialize () {\n        feedbackTabListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n        doneListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n        notDoneListView.getSelectionModel().setSelectionMode(SelectionMode.MULTIPLE);\n\n        // Feedback\n        Feedback template;\n        template = feedbackManager.importSavedTemplate();\n        if (template == null)\n            template = new Feedback();\n        setFeedbackTemplate(template);\n\n        // Feedback\n        List<Feedback> feedbackList = feedbackManager.importSavedFeedback();\n        if (feedbackList != null)\n            // feedbackManager.importFeedback(feedbackList); //TODO\n            for (Feedback feedback : feedbackList)\n                createFeedbackTab(feedback);\n\n        if (feedbackManager.getFeedbackList().isEmpty())\n            rootTabPane.getSelectionModel().select(setupTab);\n\n        updateFeedbackTabLockStatus();\n    }\n\n    public void setFeedbackTemplate (Feedback template) {\n        if (template == null)\n            return;\n\n        updateTemplate(template);\n    }\n\n    private void updateTemplate (Feedback template) {\n        feedbackManager.setTemplate(template);\n        teacherField.setText((template.getSignature()));\n        assignmentField.setText(template.getAssignment());\n        templateTextArea.setText(template.getContent());\n        templateHeaderTextArea.setText(template.getHeader());\n        templateFooterTextArea.setText(template.getFooter());\n    }\n\n    public void onMouseClicked (MouseEvent event) {\n        GroupTab tab = (GroupTab) feedbackTabListView.getSelectionModel().getSelectedItem();\n        if (event.getButton().equals(MouseButton.PRIMARY) && tab != null) { // mouseEvent.isPrimaryButtonDown()\n            if (feedbackTabPane.getTabs().contains(tab))\n                feedbackTabPane.getSelectionModel().select(tab);\n            else\n                feedbackTabPane.getTabs().add(tab);\n\n            if (event.getClickCount() > 1)\n                preview();\n        }\n        updateFeedbackTabLockStatus();\n    }\n\n    public void clear () {\n        String contentText = \"Really delete all feedback? There are currently \" + feedbackManager.getFeedbackList().size() + \" items.\";\n        Alert alert = new Alert(Alert.AlertType.CONFIRMATION, contentText, ButtonType.OK, ButtonType.CANCEL);\n        alert.setHeaderText(\"Really delete all feedback?\");\n\n        Optional<ButtonType> result = alert.showAndWait();\n        if (result.isPresent() && result.get() == ButtonType.OK)\n            clearFeedback();\n    }\n\n    private void clearFeedback () {\n        feedbackTabPane.getTabs().removeAll(groupTabs);\n        feedbackTabListView.getItems().clear();\n        feedbackManager.clear();\n        groupTabs.clear();\n        updateFeedbackTabLockStatus();\n    }\n\n    public void changeFeedbackGroup () {\n        GroupTab tab = (GroupTab) feedbackTabListView.getSelectionModel().getSelectedItem();\n        if (tab == null)\n            return;\n\n        changeFeedbackGroup(tab);\n    }\n\n    private void changeFeedbackGroup (GroupTab tab) {\n        Feedback feedback = tab.getFeedback();\n\n        TextInputDialog dialog = new TextInputDialog(feedback.getGroup());\n        dialog.setTitle(\"Change group number\");\n        dialog.setHeaderText(\"Change group number\");\n        dialog.setContentText(\"Enter new group number: \");\n        Optional<String> result = dialog.showAndWait();\n\n        if (result.isPresent() && result.get() != null) {\n            String newGroup = result.get();\n            tab.setTitle(newGroup);\n            feedback.setGroup(newGroup);\n            feedbackTabListView.refresh();\n        }\n    }\n\n    public void save () {\n        Tools.exportSavedFeedback(feedbackManager.getFeedbackList());\n\n        // Feedback\n        Feedback template = new Feedback();\n        template.setSignature(teacherField.getText());\n        template.setContent(templateTextArea.getText());\n        template.setHeader(templateHeaderTextArea.getText());\n        template.setFooter(templateFooterTextArea.getText());\n        template.setAssignment(getAssignment());\n        Tools.exportSavedTemplate(template);\n    }\n\n    public void preview () {\n        GroupTab tab = (GroupTab) feedbackTabListView.getSelectionModel().getSelectedItem();\n        preview(tab);\n    }\n\n    private void preview (GroupTab tab) {\n        if (tab == null)\n            return;\n\n        Feedback feedback = tab.getFeedback();\n        updateTemplate();\n        feedbackManager.updateFeedback(feedback);\n        FeedbackManager.preview(feedback);\n    }\n\n    public void quickInsert (Pasta pasta) {\n        GroupTab tab = (GroupTab) feedbackTabPane.getSelectionModel().getSelectedItem();\n        if (tab == null)\n            return;\n        tab.quickInsert(pasta);\n    }\n\n    // region Status\n    // ================================================================================= //\n    // Status\n    // ================================================================================= //\n\n    /**\n     * Called from main controller.\n     */\n    public void toggleDoneTab () {\n        Tab tab = feedbackTabPane.getSelectionModel().getSelectedItem();\n        toggleDone((GroupTab) tab, true);\n    }\n\n    /**\n     * Toggle done for the list.\n     */\n    public void toggleDone () {\n        // TODO focus\n        // if (!feedbackTabListView.isFocused())\n        //    return;\n\n        List<Object> selectedItems = feedbackTabListView.getSelectionModel().getSelectedItems();\n\n        if (!selectedItems.isEmpty()) {\n            for (Object o : selectedItems)\n                toggleDone((GroupTab) o, false);\n\n            if (feedbackManager.isAllFeedbackDone())\n                allFeedbackDone();\n        }\n    }\n\n    public void toggleDone (GroupTab tab, boolean checkAllDone) {\n        if (tab == null)\n            return;\n\n        Feedback feedback = tab.getFeedback();\n        feedbackManager.setDoneStatus(feedback, !feedback.isDone());\n        tab.updateTitle();\n\n        if (feedback.isDone())\n            feedbackTabPane.getTabs().remove(tab);\n        if (hideDoneItems)\n            feedbackTabListView.getItems().removeAll(tab);\n        else\n            feedbackTabListView.refresh();\n\n        if (checkAllDone && feedbackManager.isAllFeedbackDone())\n            allFeedbackDone();\n\n        updateFeedbackTabLockStatus();\n    }\n\n    private void allFeedbackDone () {\n        String contentText = \"All feedback is done! Export to .txt-files?\";\n        Alert alert = new Alert(Alert.AlertType.INFORMATION, contentText, ButtonType.YES, ButtonType.NO);\n        alert.setHeaderText(\"All feedback done!\");\n\n        Optional<ButtonType> result = alert.showAndWait();\n        if (result.isPresent() && result.get() == ButtonType.YES)\n            exportAllFeedback();\n    }\n\n    public void toggleHideDoneItems (Event event) {\n        CheckBox cb = (CheckBox) event.getSource();\n\n        hideDoneItems = cb.isSelected();\n\n        if (hideDoneItems) {\n            List<Feedback> doneFeedbackList = feedbackManager.getDoneFeedbackList();\n            List<GroupTab> doneGroupTabs = getFeedbackTabs(doneFeedbackList);\n\n            feedbackTabPane.getTabs().removeAll(doneGroupTabs);\n            feedbackTabListView.getItems().removeAll(doneGroupTabs);\n\n            if (feedbackManager.isAllFeedbackDone())\n                allFeedbackDone();\n        } else {\n            feedbackTabListView.getItems().clear();\n            feedbackTabListView.getItems().addAll(groupTabs);\n        }\n\n        updateFeedbackTabLockStatus();\n    }\n\n    public void feedbackKeyTyped (KeyEvent event) {\n        if (!feedbackTabPane.isFocused())\n            return;\n\n        Tab tab = feedbackTabPane.getSelectionModel().getSelectedItem();\n        if (tab != null && event.isControlDown() && event.getCode() == KeyCode.D) {\n            toggleDone((GroupTab) tab, true);\n            event.consume();\n        }\n    }\n\n    public void onSelectionChanged (Event event) {\n        Tab statisticsTab = (Tab) event.getSource();\n        if (!statisticsTab.isSelected())\n            return;\n\n        updateStatistics();\n    }\n\n    public void updateStatistics () {\n        int tot = feedbackManager.getFeedbackList().size();\n        int done = feedbackManager.getDoneFeedbackList().size();\n\n        numFeedback.setText(tot + \"\");\n        numDone.setText(done + \"\");\n        numNotDone.setText(feedbackManager.getNotDoneFeedbackList().size() + \"\");\n\n        if (tot == 0) {\n            progressBar.setProgress(-1);\n            progressLabel.setText(\"-\");\n        } else {\n            double pDone = (double) done / tot;\n            progressLabel.setText((int) (pDone * 100 + 0.5) + \" %\");\n            progressBar.setProgress(pDone);\n        }\n\n        updateStatusLists();\n    }\n\n    private void updateStatusLists () {\n        doneListView.getItems().clear();\n        notDoneListView.getItems().clear();\n\n        List<Feedback> done = feedbackManager.getDoneFeedbackList();\n        doneListView.getItems().clear();\n        doneListView.getItems().addAll(getFeedbackTabs(done));\n\n        List<Feedback> notDone = feedbackManager.getNotDoneFeedbackList();\n        notDoneListView.getItems().clear();\n        notDoneListView.getItems().addAll(getFeedbackTabs(notDone));\n    }\n\n    public void exportAllDone () {\n        List<Feedback> feedbackList = feedbackManager.getDoneFeedbackList();\n        suppressClearDoneDialog = exportFeedback(feedbackList, true, true);\n\n        if (suppressClearDoneDialog) {\n            // Reset after a little while\n            Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(SUPPRESS_CONFIRMATION_DURATION), ae -> suppressClearDoneDialog = false));\n            timeline.play();\n        }\n    }\n\n    public void clearDone () {\n        List<Feedback> feedbackList = feedbackManager.getDoneFeedbackList();\n        if (suppressClearDoneDialog || Tools.confirmDelete(feedbackList.size())) {\n            feedbackManager.removeFeedback(feedbackList);\n            updateStatusLists();\n            removeFeedbackTabs(feedbackList);\n        }\n        updateStatistics();\n    }\n\n    public void exportAllNotDone () {\n        List<Feedback> feedbackList = feedbackManager.getNotDoneFeedbackList();\n        suppressClearNotDoneDialog = exportFeedback(feedbackList, true, true);\n\n        // Reset after a little while\n        if (suppressClearNotDoneDialog) {\n            Timeline timeline = new Timeline(new KeyFrame(Duration.seconds(SUPPRESS_CONFIRMATION_DURATION), ae -> suppressClearNotDoneDialog = false));\n            timeline.play();\n        }\n    }\n\n    public void clearAllNotDone () {\n        List<Feedback> feedbackList = feedbackManager.getNotDoneFeedbackList();\n        if (suppressClearNotDoneDialog || Tools.confirmDelete(feedbackList.size())) {\n            feedbackManager.removeFeedback(feedbackList);\n            updateStatusLists();\n            removeFeedbackTabs(feedbackList);\n        }\n        updateStatistics();\n    }\n\n    public String getAssignment () {\n        String assignment = assignmentField.getText();\n\n        if (assignment != null)\n            assignment = assignment.replaceAll(\"\\\\s+\", \"\");\n\n        return assignment;\n    }\n\n    public void selectView (int i) {\n        rootTabPane.getSelectionModel().select(i);\n    }\n    // endregion\n}\n",
      "GroupTab.java": "package gui.feedback;\n\nimport javafx.scene.control.Tab;\nimport javafx.scene.control.TabPane;\nimport javafx.util.Pair;\nimport model.Feedback;\nimport model.Pasta;\n\n/**\n * Created by Richard Sundqvist on 19/02/2017.\n */\npublic class GroupTab extends Tab implements StudentFileViewerController.FileFeedbackListener {\n    public static final int MIN_TITLE_LENGTH = 6;\n    public static final boolean SWITCH_TO_FEEDBACK_ON_QUICKINSERT = false;\n\n    private final Feedback feedback;\n    private final FeedbackText feedbackText;\n    private final TabPane viewsPane;\n    private final Tab feedbackView, fileView;\n    private final StudentFileViewer studentFileViewer;\n\n    public GroupTab (Feedback feedback) {\n        this.feedback = feedback;\n        feedbackText = new FeedbackText(feedback);\n\n        viewsPane = new TabPane();\n\n        feedbackView = new Tab(\"Student Feedback\");\n        feedbackView.setContent(feedbackText);\n        feedbackView.setClosable(false);\n\n        studentFileViewer = new StudentFileViewer(this, feedback);\n        fileView = new Tab();\n        updateStudentFilesText(); // TODO: Update after import through drag-and-drop, etc\n        fileView.setContent(studentFileViewer);\n        fileView.setClosable(false);\n\n        viewsPane.getTabs().addAll(feedbackView, fileView);\n\n        setContent(viewsPane);\n        setClosable(true);\n        updateTitle();\n    }\n\n    private void updateFeedback () {\n        feedback.setContent(feedbackText.getText()); // TODO Too many calls?\n    }\n\n    public Feedback getFeedback () {\n        feedback.setContent(feedbackText.getText());\n        return feedback;\n    }\n\n    public void addFile (String fileName, String content) {\n        studentFileViewer.addFile(fileName, content);\n    }\n\n    public void updateStudentFilesText () {\n        int size = feedback.getFiles().keySet().size();\n        fileView.setText(\"Student Files ( \" + size + \" )\");\n    }\n\n    public String toString () {\n        return getText();\n    }\n\n    public void setTitle (String title) {\n        if (title == null || title.equals(\"\")) {\n            title = \"<Unknown group>\";\n        }\n        if (title.length() < MIN_TITLE_LENGTH) {\n            StringBuilder sb = new StringBuilder(title);\n            while (sb.length() <= MIN_TITLE_LENGTH) {\n                sb.append(\" \");\n            }\n            title = sb.toString();\n        }\n        setText(title);\n    }\n\n    public void updateTitle () {\n        feedbackText.updateColor();\n        setTitle(feedback.getGroup() + (feedback.isDone() ? \" \\u2713\" : \"\"));\n    }\n\n    @Override\n    public void feedbackAt (String file, int caretLine, int caretColumn, int caretPosition) {\n        feedbackText.feedbackAt(file, caretLine, caretColumn, caretPosition);\n        viewsPane.getSelectionModel().select(feedbackView);\n    }\n\n    public void feedbackAt (String file, String content, int caretLine, int caretColumn, int caretPosition) {\n        feedbackText.feedbackAt(file, content, caretLine, caretColumn, caretPosition);\n        viewsPane.getSelectionModel().select(feedbackView);\n    }\n\n    public void quickInsert (Pasta pasta) {\n        Tab tab = viewsPane.getSelectionModel().getSelectedItem();\n        if (tab == null || pasta == null)\n            return;\n\n        if (tab == feedbackView)\n            feedbackText.insertTextAtCaret(pasta.getContent());\n        else if (tab == fileView) {\n            Pair<String, Integer> fileAndCaretPos = studentFileViewer.getController().getCurrentFileAndCaretPos();\n            StudentFileViewerController ctrl = studentFileViewer.getController();\n\n            feedbackText.feedbackAt(fileAndCaretPos.getKey(), pasta.getContent(), ctrl.getCaretLine(), ctrl.getCaretColumn(), -1);\n\n            studentFileViewer.getController().flashCopiedlabel();\n            if (SWITCH_TO_FEEDBACK_ON_QUICKINSERT)\n                viewsPane.getSelectionModel().select(feedbackView);\n        }\n    }\n}\n",
      "hint.txt": "Try to import the \"folder_import_example\" folder found in the examples folder! Files can be\nof any plaintext format, however Java syntax highlight will always be applied.\n",
      "FeedbackText.java": "package gui.feedback;\n\nimport gui.Settings;\nimport javafx.scene.layout.BorderPane;\nimport model.Feedback;\nimport org.fxmisc.flowless.VirtualizedScrollPane;\nimport org.fxmisc.richtext.CodeArea;\nimport org.fxmisc.richtext.LineNumberFactory;\nimport org.fxmisc.richtext.ViewActions;\nimport org.fxmisc.richtext.model.StyleSpans;\nimport org.fxmisc.richtext.model.StyleSpansBuilder;\n\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\n/**\n * Created by Richard Sundqvist on 12/04/2017.\n */\npublic class FeedbackText extends BorderPane implements StudentFileViewerController.FileFeedbackListener {\n\n    // region strings\n    private static final String TAG_PATTERN = \"\\\\%(.*?)\\\\%\";\n\n    private static final Pattern PATTERN = Pattern.compile(\"(?<TAG>\" + TAG_PATTERN + \")\");\n    // endregion\n\n    private final CodeArea codeArea;\n    private final Feedback feedback;\n\n    public FeedbackText (Feedback feedback) {\n        this.feedback = feedback;\n        codeArea = new CodeArea();\n        codeArea.setParagraphGraphicFactory(LineNumberFactory.get(codeArea));\n        codeArea.setShowCaret(ViewActions.CaretVisibility.ON);\n        codeArea.textProperty().addListener(event -> {\n            feedback.setContent(codeArea.getText());\n        });\n\n        codeArea.richChanges().filter(ch -> !ch.getInserted().equals(ch.getRemoved())).subscribe(change -> {\n            String text = codeArea.getText();\n            if (text != null && !text.isEmpty()) // Prevent exception\n                codeArea.setStyleSpans(0, computeHighlighting(text));\n        });\n        setCenter(new VirtualizedScrollPane<>(codeArea));\n        codeArea.replaceText(0, 0, feedback.getContent());\n        updateColor();\n    }\n\n    private static StyleSpans<Collection<String>> computeHighlighting (String text) {\n        Matcher matcher = PATTERN.matcher(text);\n        int lastKwEnd = 0;\n        StyleSpansBuilder<Collection<String>> spansBuilder = new StyleSpansBuilder<>();\n        while (matcher.find()) {\n            String styleClass = matcher.group(\"TAG\") != null ? \"tag\" : null; /* never happens */\n            assert styleClass != null;\n            spansBuilder.add(Collections.emptyList(), matcher.start() - lastKwEnd);\n            spansBuilder.add(Collections.singleton(styleClass), matcher.end() - matcher.start());\n            lastKwEnd = matcher.end();\n        }\n        spansBuilder.add(Collections.emptyList(), text.length() - lastKwEnd);\n        return spansBuilder.create();\n    }\n\n    public String getText () {\n        return codeArea.getText();\n    }\n\n    public void updateColor () {\n        if (feedback.isDone())\n            codeArea.setStyle(\"-fx-font-family: consolas; -fx-font-size: 11pt; -fx-background-color: #55e055;\");\n        else\n            codeArea.setStyle(\"-fx-font-family: consolas; -fx-font-size: 11pt; -fx-background-color: #dddddd;\");\n    }\n\n    private static String caretString (int caretLine, int caretColumn) {\n        StringBuilder stringBuilder = new StringBuilder();\n\n        if (caretLine != -1) {\n            stringBuilder.append(\"L\" + caretLine);\n            if (caretColumn != -1)\n                stringBuilder.append(\", \");\n        }\n        if (caretColumn != -1)\n            stringBuilder.append(\"C\" + caretColumn);\n\n        return stringBuilder.toString();\n    }\n\n    @Override\n    public void feedbackAt (String file, int caretLine, int caretColumn, int caretPosition) {\n        int pos = feedback.getFilePosition(file);\n\n        String caretInfo = caretString(caretLine, caretColumn);\n        String text = \"\\nAt \" + caretInfo + \":  \\n\";\n        if (pos < 0) { // No FILE-tag\n            pos = feedback.getContent().indexOf(Feedback.FOOTER) - 1; // Place above footer, if it exists.\n            if (pos < 0) // No footer - place at end of file.\n                pos = feedback.getContent().length();\n\n            text = fileTagString(file) + text;\n        }\n        insertText(pos, text);\n    }\n\n    private static String fileTagString (String file) {\n        file = \" \" + file + \" \";\n        if (file.length() % 2 != 0)\n            file = file + \" \";\n\n        int sz = (Settings.FILE_DECORATION_WIDTH - file.length()) / 2; // space per side\n        int numRepeats = sz / 2;\n        String extra = sz % 2 == 0 ? \"\" : \"<>\";\n\n        String around = new String(new char[numRepeats]).replace(\"\\0\", \"<>\");\n        String border = new String(new char[80]).replace(\"\\0\", \"=\"); // Width 80\n        return \"\\n\\n\" + border + \"\\n\" + around + file + around + extra + \"\\n\" + border + \"\\n\" + Feedback.getFileTag(file);\n    }\n\n    public void feedbackAt (String file, String content, int caretLine, int caretColumn, int caretPosition) {\n        String text;\n        if (caretLine < 0 && caretColumn < 0)\n            text = \"\\n\";\n        else\n            text = \"\\nAt \" + caretString(caretLine, caretColumn) + \":\\n\";\n\n        int pos = feedback.getFilePosition(file);\n        if (pos < 0) { // No FILE-tag or footer present.\n            pos = feedback.getContent().indexOf(Feedback.FOOTER) - 1; // Place above footer, if it exists.\n            if (pos < 0) // No footer - place at end of file.\n                pos = feedback.getContent().length();\n\n            text = fileTagString(file) + text;\n        }\n        insertText(pos, text + content);\n    }\n\n    public void insertText (int pos, String s) {\n        codeArea.insertText(pos, s);\n    }\n\n    public void insertTextAtCaret (String s) {\n        insertText(codeArea.getCaretPosition(), s);\n    }\n}\n"
    },
    "possibleGrades": [],
    "header": "Hello! This is the header.\n\nThis is usally a good place to put information which doesn't change between\nassignments, such as grading policy. I'm gonna use it to tell you about some\nfeatures instead:\n\nImport a template (Feedback -> Import Template), but not quite yet. It will\nreplace what you're reading now.\n\nImport groups from folder structures\n    1. A single root folder is assumed to contain a one folder per\n       group. Any subfolders of top-level subfolders will be group property.\n    2. Set file filters (e.g. java) to select the types of files to import.\n    3. Click done or close the window. The program will ask you if you want to\n       clear old groups or just import the new ones. Feedback will be created\n       for each group, based on the template.\n\nSick of writing the same thing over and over again?\n    1. Open the Pasta Editor (Ctrl+G) and click \"New Pasta\"\n    2. Create and add tags to organize items by content and by assignment.\n    3. Close the window. The program will ask if you want to use the new pasta.\n\nQuick insert (Pasta) at caret\n    1. Select a Pasta item (the search function is your friend) and select a\n       position in a student file.\n    2. Press (Ctrl+Q) or right-click the pasta list. The pasta will be pasted\n       into the student feedback referencing the current file and position.\n       Some examples are included to let you try this out.\n\nWhen youre done, you can export everything as individual files using (Ctrl+E).\nYou can also double-click (or right click) a group in the list to get a preview.",
    "content": "\n%HEADER%\n\nThis is the body. There are a few tags you should know about:\n\nThe %GROUP% tag simply indicates the name of the group being graded. It is the\nsame as the values shown in the feedback lists.\n\nThe %GRADE% tag indicates the grade of the group. It must be one of the possible\ngrades for the task, or \"Not set\", which is the default value.\n\nThe %MANUAL% tag indicates that some part of the template (it may also be\npresent in Pasta) is not to be exported as-is. For example, it may include code\nsnippets that should be altered to fit the current group being graded. This is\nthe ONLY tag which will not be removed when exporting.\n\nThe %FILE: <filename>% tag is special. It can be used to give feedback\nreferencing an appropriate row and file (and column, if you like). If you did\nnot use the automatic import function (Ctrl+I), files can be dragged-and-dropped\nonto the file view of a group to add it. \n\nAbout files:\n================================================================================\n<><><><><><><><><><><><><><><><> Main.java  <><><><><><><><><><><><><><><><><><>\n================================================================================\n%FILE:  Main.java  % <-- This is a file tag. \n\nThis is what an automatic file section looks like (the width, currently 80, can\nbe changed in the settings). It will be created the the bottom of the document\nif no footer tag is present. The tags are created automatically if they are not\npresent when a file related function is used.\n\n\n================================================================================\n<><><><><><><><><><><><><><><> JavaCodeArea.java  <><><><><><><><><><><><><><><>\n================================================================================\n%FILE:  JavaCodeArea.java  %\nAt L20:  \nWrap long lines; it makes them easier to read.\n\nAt L28, C54:  \nNice regex you got there.\n\n\n================================================================================\n<><><><><><><><><><><><><><><> FeedbackText.java  <><><><><><><><><><><><><><><>\n================================================================================\n%FILE:  FeedbackText.java  %\nAt L117, C46:  \nFound a bug!\n\n%FOOTER%\n",
    "footer": "\nThis is the footer. This is a good place to include the signature tag.\nSimply including it in the body may cause issues with the automatic\ncreation of file tags. If the file tags are already present, its not an issue.\n\nThank you for using CopyPasta!\n%SIGNATURE%                                    \n\n\n  _______________________________\n /\\                              \\\n/++\\    __________________________\\\n\\+++\\   \\ ************************/\n \\+++\\   \\___________________ ***/\n  \\+++\\   \\             /+++/***/\n   \\+++\\   \\           /+++/***/\n    \\+++\\   \\         /+++/***/\n     \\+++\\   \\       /+++/***/\n      \\+++\\   \\     /+++/***/\n       \\+++\\   \\   /+++/***/\n        \\+++\\   \\ /+++/***/\n         \\+++\\   /+++/***/\n          \\+++\\ /+++/***/\n           \\+++++++/***/\n            \\+++++/***/\n             \\+++/***/\n              \\+/___/",
    "group": "group_with_some_files",
    "grade": "B-",
    "signature": "Richard Sundqvist (richard.sundqvist@live.se)",
    "notes": "Notes. Notes. Notesnotes. Notesnotesnotes, Notesnotesnotesnotes\n\nUseful for remembering stuff I guess. Will not be visible to the student in any way.",
    "assignment": "",
    "done": false
  },
  {
    "files": {},
    "possibleGrades": [],
    "header": "Hello! This is the header.\n\nThis is usally a good place to put information which doesn't change between\nassignments, such as grading policy. I'm gonna use it to tell you about some\nfeatures instead:\n\nImport a template (Feedback -> Import Template), but not quite yet. It will\nreplace what you're reading now.\n\nImport groups from folder structures\n    1. A single root folder is assumed to contain a one folder per\n       group. Any subfolders of top-level subfolders will be group property.\n    2. Set file filters (e.g. java) to select the types of files to import.\n    3. Click done or close the window. The program will ask you if you want to\n       clear old groups or just import the new ones. Feedback will be created\n       for each group, based on the template.\n\nSick of writing the same thing over and over again?\n    1. Open the Pasta Editor (Ctrl+G) and click \"New Pasta\"\n    2. Create and add tags to organize items by content and by assignment.\n    3. Close the window. The program will ask if you want to use the new pasta.\n\nQuick insert (Pasta) at caret\n    1. Select a Pasta item (the search function is your friend) and select a\n       position in a student file.\n    2. Press (Ctrl+Q) or right-click the pasta list. The pasta will be pasted\n       into the student feedback referencing the current file and position.\n       Some examples are included to let you try this out.\n\nWhen youre done, you can export everything as individual files using (Ctrl+E).\nYou can also double-click (or right click) a group in the list to get a preview.",
    "content": "\n%HEADER%\n\nThis is the body. There are a few tags you should know about:\n\nThe %GROUP% tag simply indicates the name of the group being graded. It is the\nsame as the values shown in the feedback lists.\n\nThe %GRADE% tag indicates the grade of the group. It must be one of the possible\ngrades for the task, or \"Not set\", which is the default value.\n\nThe %MANUAL% tag indicates that some part of the template (it may also be\npresent in Pasta) is not to be exported as-is. For example, it may include code\nsnippets that should be altered to fit the current group being graded. This is\nthe ONLY tag which will not be removed when exporting.\n\nThe %FILE: <filename>% tag is special. It can be used to give feedback\nreferencing an appropriate row and file (and column, if you like). If you did\nnot use the automatic import function (Ctrl+I), files can be dragged-and-dropped\nonto the file view of a group to add it. \n\nAbout files:\n================================================================================\n<><><><><><><><><><><><><><><><> Main.java  <><><><><><><><><><><><><><><><><><>\n================================================================================\n%FILE:  Main.java  % <-- This is a file tag. \n\nThis is what an automatic file section looks like (the width, currently 80, can\nbe changed in the settings). It will be created the the bottom of the document\nif no footer tag is present. The tags are created automatically if they are not\npresent when a file related function is used.\n\n%FOOTER%\n",
    "footer": "\nThis is the footer. This is a good place to include the signature tag.\nSimply including it in the body may cause issues with the automatic\ncreation of file tags. If the file tags are already present, its not an issue.\n\nThank you for using CopyPasta!\n%SIGNATURE%                                    \n\n\n  _______________________________\n /\\                              \\\n/++\\    __________________________\\\n\\+++\\   \\ ************************/\n \\+++\\   \\___________________ ***/\n  \\+++\\   \\             /+++/***/\n   \\+++\\   \\           /+++/***/\n    \\+++\\   \\         /+++/***/\n     \\+++\\   \\       /+++/***/\n      \\+++\\   \\     /+++/***/\n       \\+++\\   \\   /+++/***/\n        \\+++\\   \\ /+++/***/\n         \\+++\\   /+++/***/\n          \\+++\\ /+++/***/\n           \\+++++++/***/\n            \\+++++/***/\n             \\+++/***/\n              \\+/___/",
    "group": "group_with_no_files",
    "grade": "F",
    "signature": "Richard Sundqvist (richard.sundqvist@live.se)",
    "notes": "You may drag-and-drop files onto the files tab to add them to the group.",
    "assignment": "",
    "done": true
  },
  {
    "files": {
      "Player.java": "/**\n*  @author Richard Sundqvist, Erik Pihl\n*  @Group 64\n*/\n\nimport java.awt.Color;\nimport java.awt.Dimension;\nimport java.awt.Font;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport javax.swing.Icon;\nimport javax.swing.JButton;\nimport javax.swing.JLabel;\nimport javax.swing.JPanel;\n\n\tpublic class Player{\n\t\t\n\t\t//class\n\t\t// inget\n\t\t\n\t\t//instance \n\t\tprivate int found = 0; //antal kortpar hittade\n\t\tprivate int attempts = 0; //antal kortpar vnda\n\t\tprivate int score = 0;\n\t\tprivate boolean weightedScore = true;\n\t\tprivate String name = \"\";\n\n\t\tprivate JPanel playerCard;\n\t\tprivate JLabel playerAttempts;\n\t\tprivate JLabel playerScore;\n\t\tprivate JButton lastFound;\n\t\t\n\n\t\t\n\t\tpublic Player(String newName, final Memory mem){\n\t\t\tplayerCard = new JPanel();\n\t\t\tplayerCard.setBackground(Color.LIGHT_GRAY); //Color.LIGHT_GRAY\n\t\t\tname = newName;\n\t\t\tJLabel playerName = new JLabel(name);\n\t\t\t\n\t\t\t//Visar senaste kortet som hittades\n\t\t\tlastFound = new JButton();\n\t\t\tlastFound.setEnabled(false);\n\t\t\tlastFound.setPreferredSize (new Dimension (140, 90));\n\t\t\tlastFound.setToolTipText(\"Visa bilden. Klicka igen fr att fortstta spela.\");\n\t\t\tlastFound.addActionListener(new ActionListener() {\n\t\t\t    public void actionPerformed(ActionEvent e) {\n\t\t\t    \tmem.viewImage(lastFound.getIcon(), Player.this);\n\t\t\t    }\n\t\t\t});\n\t\t\t\n\t\t\tplayerAttempts = new JLabel(\"Vnda kortpar: \" + attempts);\n\t\t\tplayerScore = new JLabel(\"<html>Hittade kortpar: \" + found + \"<br> Pong: \" + score + \"</html>\");\n\t\t\t\n\t\t\tplayerName.setFont(new Font(\"Tahoma\", Font.BOLD, 15));\n\t\t\tplayerAttempts.setFont(new Font(\"Arial\", Font.BOLD, 10));\n\t\t\tplayerScore.setFont(new Font(\"Arial\", Font.BOLD, 10));\n\t\t\t\n\t\t\tplayerName.setPreferredSize(new Dimension(100, 20));\n\t\t\tplayerAttempts.setPreferredSize(new Dimension(100, 20));\n\t\t\tplayerScore.setPreferredSize(new Dimension(100, 40));\n\t\t\t\n\t\t\tplayerCard.add(playerName);\n\t\t\tplayerCard.add(playerAttempts);\n\t\t\tplayerCard.add(playerScore);\n\t\t\tplayerCard.add(lastFound);\n\t\t\tmem.addPlayerCard(playerCard);\n\t\t}\n\t\t\n\t\t//GETTERS and SETTERS\n\t\tpublic String getPlayerName(){\n\t\t\treturn name;\n\t\t}\n\t\t\n\t\tpublic void setWeightedScore(boolean set){\n\t\t\tweightedScore = set;\n\t\t}\n\t\t\n\t\tpublic int getPlayerScore(){\n\t\t\treturn this.score;\n\t\t}\n\t\t\n\t\t//Functional methods\n\t\t\n\t\tpublic void guessRight(Memory mem){\n\t\t\tthis.found++;\n\t\t\tthis.attempts++;\n\t\t\tthis.playerScore(true, mem);\n\t\t\tplayerAttempts.setText(\"Vnda kortpar: \" + attempts);\n\t\t\tplayerScore.setText(\"<html>Hittade kortpar: \" + found+\"<br> Pong: \" + score + \"</html>\");\n\t\t\t\n\t\t}\n\t\tpublic void setFoundIcon(Icon pic){\n\t\t\tthis.lastFound.setIcon(pic); \n\t\t\tlastFound.setEnabled(true);\n\t\t}\n\t\tpublic void guessWrong(Memory mem){\n\t\t\tthis.attempts++;\n\t\t\tthis.playerScore(false, mem);\n\t\t\tplayerAttempts.setText(\"Vnda kortpar: \" + attempts);\n\t\t\tplayerScore.setText(\"<html>Hittade kortpar: \" + found+\"<br> Pong: \" + score + \"</html>\");\n\t\t}\n\t\tpublic void setActivePlayer(Player previousPlayer){\n\t\t\tpreviousPlayer.playerCard.setBackground(Color.LIGHT_GRAY);\n\t\t\tthis.playerCard.setBackground(Color.GREEN);\n\t\t}\n\t\t\n\t\tpublic void playerScore(boolean rightAns, Memory mem){\n\t\t\t//viktade pong\n\t\t\tif (weightedScore){\n\t\t\t\tif (rightAns){\n\t\t\t\t\tthis.score = this.score+5*mem.getNbrOfCards();\n\t\t\t\t} else {\n\t\t\t\t\tthis.score = this.score-this.attempts*5/mem.getNbrOfCards();\n\t\t\t\t\tif (this.score < 0){\n\t\t\t\t\t\tthis.score = 0;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t//ej viktade pong\t\n\t\t\t} else if (!weightedScore && rightAns) {\n\t\t\t\tthis.score = this.score+10;\n\t\t\t}\n\t\t\t//TODO: svvande text ver kortet som visar hur mnga pong man fick\n\t\t} //End METHOD playerScore\n\t\t\n\t} //End CLASS Player\n",
      "Verktyg.java": "/**\n*  @author Richard Sundqvist, Erik Pihl\n*  @Group 64\n*/\n\npublic class Verktyg {\n    \n    public static void slumpOrdning (Object[] obj){\n        \n        Object[] tmp = new Object[obj.length];\n        \n        for (int i = 0; i<obj.length;){ //Randomize order\n            int random_index = (int) (Math.random()*obj.length);\n            if (tmp[random_index] == null){\n                tmp[random_index] = obj[i];\n                i++;\n            }\t\n        } \n        for (int i = 0; i<obj.length; i++){ //Return objects in randomized order, \n             obj[i]=tmp[i];\n        }\n        \n    }\n}\n",
      "Kort.java": "/**\n*  @author Richard Sundqvist, Erik Pihl\n*  @Group 64\n*/\n\nimport java.awt.Color;\nimport javax.swing.*;\n\n@SuppressWarnings(\"serial\")\npublic class Kort extends JButton {\n\t\n\t//MISC\n\tpublic enum Status {DOLT, SYNLIGT, SAKNAS};\n\tprivate Status status;\n\tprivate Icon picture;\n\t\n\tpublic Kort(Icon pic){\n\t\tthis(pic, Status.SAKNAS);\n\t}\n\tpublic Kort(Icon pic, Status sta){\n\t\tsuper(pic);\n\t\tthis.setDisabledIcon(pic); //hindrar gr vid disable\n\t\tthis.picture = pic;\n\t\tthis.status = sta;\n\t\tstatusHandler(sta); \n\t}\n\t\n\tpublic void setStatus(Status sta) {\n\t\tthis.status=sta;\n\t\tstatusHandler(sta);\n\t}\n\tprivate void statusHandler(Status sta){\n\t\tif (sta == Status.DOLT){\n\t\t\tthis.setBackground(Color.BLUE);\n\t\t\tthis.setIcon(null);\n\t\t} else if (sta == Status.SYNLIGT){\n\t\t\tthis.setIcon(this.picture);\n\t\t\t//this.setBackground(Color.WHITE); //tycker det r snyggare shr, men korttest krver att bakgrunden frblir bl\n\t\t} else {\n\t\t\tthis.setBackground(Color.WHITE);\n\t\t\tthis.setIcon(null);\n\t\t}\n\t}\n\t\n\tpublic Status getStatus() {\n\t\treturn this.status;\n\t}\n\t\n\tpublic Kort copy() {\n\t\treturn new Kort(this.picture, this.status);\n\t}\n\t\n\tpublic boolean sammaBild(Kort rhs) {\n\t\tif (rhs instanceof Kort || rhs != null){\n\t\t\treturn this.picture.equals(rhs.picture);\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\t\n\t\n} //END KORT CLASS\n\n\n\n",
      "readme.txt": "/**\n*  @author Richard Sundqvist, Erik Pihl\n*  @Group 64\n*/\n\nKortvisare: Klicka p kortikonen p spelarkortet fr att visa det senaste kortet i full storlek.\nTyckte det var roligare att ha bilder med lite detalj, nackdelen blir att man ibland inte ser hela bilden p spelplan.\n\nViktade pong: Huvudsakligen dr fr singleplayer, men tyckte det var roligare n att bara rkna hittade kort\n\nUPPDATERINGAR:\n21:35 2013-10-16\nMemory\t\t\t\tFixade en bugg som gjorde att storleken p spelplan lste sig nr bildvisaren anvndes\n\n--reject--\n\n10:43 2013-10-23\n*Joakim\n#egna grejer\n-reviderad, se ovanstende rad fr aktuell lsning\n\nKort\t\t\t\t*Skrev om sammaBild fr att kontrollera nullpekare samt objekttyp.\n\t\t\t\t\t*Frenklade konstruktorn (sign. public Kort(Icon pic)).\n\t\t\t\t\t*statusHandler stter inte vit p ett synligt kort, detta fr att klara Korttest. (tycker det r snyggare med vit bakgrund..)\n\t\t\t\t\t\nPlayer\t\t\t\t*Tog bort PlayerList, detta var en rest frn ett misslyckat frsk att anvnda reflextion fr att nollstlla variabler.\n\t\t\t\t\t*ndrade synligheten fr lastFound till private, anvnds inte utanfr klassen.\n\t\t\t\t\t*Gjorde nbrOfPlayrs till private, skapade getter. Setter finns och anvnds sen tidigare.\n\t\t\t\t\t\n\t\t\t\t\t#Tog bort oanvnd klassvariabel prevScore, Memorys lastScore fyller samma funktion.\n\t\t\t\t\t#Gjorde weightedScore till private, skapade Setter.\n\t\t\t\t\t\t\t\t\t\t#ndrade synligheten fr score till private, skapade getter.\n\t\t\t\t\t#Konstruktorn fr Player tar nu en strng.\n\t\t\t\t\t\n\nMemory\t\t\t\t*Nstan alla variabler r nu endast private.\n\t\t\t\t\t*Spelarfltet p r nu endast privat, den anvnds inte utanfr Memory. (ej heller i versionen som lmnades in)\n\t\t\t\t\t*firstCardSelected kallas nu firstCardSelection, stts till true i nyttSpel().\n\t\t\t\t\t*ndrat matchAttempt s att den schemalagda delen endast krs om man inte anropar nyttSpel() under tiden.\t\t\t\t\t\n\t\t\t\t\t\t-Lyssnaren fr game_newGame anropar nu nyttSpel() endast d timerNotRunning r satt till true\n\t\t\t\t\t\t (hur lsa p ett snyggare stt?).\n\t\t\t\t\t\t \n\t\t\t\t\t#Fixade en bugg som gjorde att programmet hoppade ver spelare om man snkte antalet spelare under en runda.\n\t\t\t\n13:41 2013-10-23\nMemory\t\t\t\t#ndrat bildvisaren s att den bara stnger bilden d man klickar p den bild som visas fr tillfllen,\n\t\t\t\t\t annars ppnas den nya bilden direkt.\n\n----------\n\nAllmnt:\n\n= Ni skapade inte en tar.gz-boll, str klart och tydligt i instruktionerna fr hur man submittar en lab p kurshemsidan.\n\nKort:\n\nklart?\n\nPlayer:\n\nklart?\n\nMemory:\n\nklart?\n",
      "Memory.java": "/**\n*  @author Richard Sundqvist, Erik Pihl\n*  @Group 64\n*/\n\nimport java.awt.*;\nimport java.awt.event.ActionEvent;\nimport java.awt.event.ActionListener;\nimport java.awt.event.ItemEvent;\nimport java.awt.event.ItemListener;\nimport java.awt.event.KeyEvent;\nimport java.io.*;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\nimport javax.swing.*;\n\n@SuppressWarnings(\"serial\")\npublic class Memory extends JFrame {\n\t\n\t//class\n\tprivate static File bildmapp = new File(\"bildmapp\");\n\tprivate static File[] bilder = bildmapp.listFiles();\n\t\t\n\t//instance\n\tprivate int currentPlayerIndex = 0;\n\tprivate int lastScore = 0;\n\tprivate int nextRows = 6;\n\tprivate int nextColumns = 6;\n\tprivate int rows = 6;\n\tprivate int columns = 6;\n\tprivate int nbrOfCards = 0;\n\tprivate int nbrOfPlayers = 0;\n\tprivate int nextNbrOfPlayers = 2;\n\tprivate int currentRound = 1;\n\n\tprivate boolean showingImage = false;\n\tprivate boolean multiplayer = true;\n\tprivate boolean timerNotRunning = true;\n\tprivate boolean firstCardSelection = true;\n\tprivate boolean weightedScore_nyttSpel = true;\n\t\t\n\tprivate Player currentPlayer = null;\n\tprivate Player currentShowingPlayer = null;\n\tprivate Player[] p = new Player[5];\n\tprivate Kort prevCard = null;\t\n\tprivate Kort currCard = null;\n\tprivate Kort[] kort = new Kort[bilder.length]; //[50]\n\n\tprivate JFrame memory;\n\tprivate JPanel spelplan;\n\tprivate JInternalFrame showImage;\n\tprivate JPanel spelare;\n\n\t\t\n\t//CONSTRUCTOR\n\tpublic Memory(){\n\t\tthis(\"Memory\", EXIT_ON_CLOSE);\n\t}\n\tpublic Memory(String str){\n\t\tthis(str, EXIT_ON_CLOSE);\n\t}\n\tpublic Memory(int exitOp){\n\t\tthis(\"Memory\", exitOp);\n\t}\n\t\n\tpublic Memory(String title, int exitOp){\t\t\n\t\t\t\n\t\t//MAIN WINDOW\n\t\tmemory=new JFrame();\n\t\tspelare = new JPanel();\n\t\tspelplan = new JPanel();\n\t\t\n\t\tDimension dim = Toolkit.getDefaultToolkit().getScreenSize();\n\t\tmemory.setSize(dim.width/5*4, dim.height/5*4); //~80% av skrmstorlek\n\t\tmemory.setLocation(dim.width/2-memory.getSize().width/2, dim.height/2-memory.getSize().height/2); //mitt i skrmen\n\t\tmemory.setDefaultCloseOperation(exitOp);\n\t\tmemory.setTitle(title);\n\t\tmemory.setLayout(new BorderLayout());\n\t\t\t\n\t\t//MENUES\n\t\tJMenuBar menubar = new JMenuBar();\n\t\tJMenu game = new JMenu(\"Spel\");\n\t\tJMenu settings = new JMenu(\"Instllningar\");\n\t\t\t\n\t\t//MENU ITEMS\n\t\tJMenuItem game_newGame = new JMenuItem(\"Nytt spel\");\n\t\tJMenuItem game_quit = new JMenuItem(\"Avsluta\");\n\t\tJMenuItem settings_nbrOfPlayers = new JMenuItem(\"ndra antalet spelare\");\n\t\tJMenuItem settings_rowsAndColumns = new JMenuItem(\"ndra spelplanens storlek\");\n\t\tfinal JCheckBoxMenuItem settings_weightedScore = new JCheckBoxMenuItem(\"Viktade pong\", true);\n\t\t\t\n\t\t//game_newGame\n\t\tgame_newGame.addActionListener(new ActionListener() {\n\t           public void actionPerformed(ActionEvent ae) {\n\t                nyttSpel();   \n\t            }\n\t\t});\n\t\tgame_newGame.setAccelerator(KeyStroke.getKeyStroke('N', KeyEvent.CTRL_DOWN_MASK)); //hotkey CTRL+N\n\t\tgame_newGame.setToolTipText(\"Starta ett nytt spel med de valda instllningarna.\");\n\t\n\t\t//game_quit\n\t\tgame_quit.addActionListener(new ActionListener() {\n\t           public void actionPerformed(ActionEvent ae) {\n\t           \t\tObject[] options0 = {\"Fortstt spela\", \"Avsluta\"};\n\t           \t\tint exit = JOptionPane.showOptionDialog(spelplan,\n\t           \t\t\t\"Verkligen avsluta? \", \"Avsluta\",JOptionPane.YES_NO_CANCEL_OPTION,\n\t            \t\tJOptionPane.QUESTION_MESSAGE, null, options0, options0[0]);\n\t            \tif (exit == 1){\n\t            \t\tSystem.exit(0);\n\t            \t}\n\t            }\n\t        });\n\t\t\t\n\t\t\t//settings_nbrOfPlayers\n\t\tfinal String[] options1 = new String[] {\"   1   \", \"   2   \", \"   3   \", \"   4   \", \"   5   \"};\n\t\tsettings_nbrOfPlayers.addActionListener(new ActionListener() {\n\t           public void actionPerformed(ActionEvent ae) {\n\t           \tnextNbrOfPlayers = (\n\t           \t\t\t1+JOptionPane.showOptionDialog(spelplan, \"Vlj antalet spelare:\", \"ndra antal spelare\",\n\t           \t\t\tJOptionPane.DEFAULT_OPTION, JOptionPane.INFORMATION_MESSAGE,\n\t           \t\t\tnull, options1, options1[0])\n\t           \t);\n\t           }\n\t    });\n\t\tsettings_nbrOfPlayers.setAccelerator(KeyStroke.getKeyStroke('W', KeyEvent.CTRL_DOWN_MASK)); //hotkey CTRL+W\n\t\t\t\n\t\t//settings_rowsAndColumns\n\t\tsettings_rowsAndColumns.addActionListener(new ActionListener() {\n\t          public void actionPerformed(ActionEvent ae) {\n\t           \tJTextField field1 = new JTextField();  \n\t           \tJTextField field2 = new JTextField();  \n\t           \tint input_rows = 0;\n\t           \tint input_columns = 0;\n\t           \tObject[] message = {  \n\t           \t    \"Du spelar just nu med \" + rows + \" rader och \" + columns + \" kolumner. \\n\\nNytt antal rader:\",\n\t           \t    field1, \"Nytt antal kolumner:\", field2,};  \n\t            int option = JOptionPane.showConfirmDialog(spelplan, message, \"ndra spelplanens storlek\", JOptionPane.OK_CANCEL_OPTION);  \n\t            if (option == JOptionPane.OK_OPTION)  \n\t           \tif (field1.getText().length() != 0 && field2.getText().length() != 0){\n\t           \t\t\n\t           \t\ttry {\n\t\t           \t\t\tinput_rows = Integer.parseInt(field1.getText());  \n\t\t           \t\t\tinput_columns = Integer.parseInt(field2.getText());\n\t\t      \n\t            \t\t\t//krs i try d den rows/cols blir 0 om length = 0,  ger tv felmeddelanden om den ligger utanfr. Bttre prestanda att anvnda en bool?\n\t            \t\t\tif (input_rows*input_columns >= 4 && input_rows*input_columns-((input_rows*input_columns)%2) <= bilder.length*2){\n\t                \t\t\tnextRows = input_rows;\n\t                \t\t\tnextColumns = input_columns;\n\t                \t\t} else {\n\t                \t\t\tJOptionPane.showMessageDialog(spelplan,\"Ogilitigt antal rader och kolumner. Spelplanen kan innehlla minst 4 och hgst \" + bilder.length*2 + \" kort.\");\n\t                \t\t}\n\t            \t} catch (NumberFormatException e) {\n\t            \t\t\tJOptionPane.showMessageDialog(spelplan,\"Endast siffror\");\n\t            \t}\t\t\n\t            }\n\t          }\n\t        });\n\t\t\tsettings_rowsAndColumns.setAccelerator(KeyStroke.getKeyStroke('D', KeyEvent.CTRL_DOWN_MASK)); //hotkey CTRL+D\n\t\t\t\n\t\t//settings_weightedScore\n\t\tsettings_weightedScore.addItemListener(new ItemListener() {\n            public void itemStateChanged(ItemEvent e) {\n\t           \tweightedScore_nyttSpel = settings_weightedScore.isSelected();\n\t           }\n\t        });\n\t\tsettings_weightedScore.setToolTipText(\"VALD: Ger spelaren pong baserat p antalet frsk och mngden kort kvar p spelplanen.\");\n\t\t\t\n\t\t//add + setVisible\n\t\tmemory.setJMenuBar(menubar);\n\t\tmenubar.add(game);\n\t\tmenubar.add(settings);\n\t\t\t\n\t\tgame.add(game_newGame);\n\t\tgame.add(game_quit);\n\t\tsettings.add(settings_nbrOfPlayers);\n\t\tsettings.add(settings_rowsAndColumns);\n\t\tsettings.add(settings_weightedScore);\n\t\t\t\n\t\tmemory.setVisible(true);\n\t\tgame.setVisible(true);\n\t\tsettings.setVisible(true);\n\t\t\t\t\t\n\t\t//PANELS\n\t\tmemory.add(spelare, BorderLayout.WEST);\n\t\tmemory.add(spelplan, BorderLayout.CENTER);\n\t\n\t\tspelplan.setLayout(new GridLayout(rows, columns));\n\t\tspelplan.setBackground(Color.white);\n\t\tspelare.setBackground(Color.LIGHT_GRAY);\n\t\tspelare.setPreferredSize(new Dimension (170, memory.getHeight()));\n\t\n\t\t//creation of cards\n\t\tfor (int i = 0; i<kort.length; i++){\n\t\t\tkort[i] = new Kort(new ImageIcon(bilder[i].getAbsolutePath()), Kort.Status.DOLT);\n\t\t\t\t\n\t\t}\n\t\t\t\n\t\tnyttSpel();\n\t\n\t} //END CONSTRUCTOR\n\t\n\n\tpublic void nyttSpel (){\n\t\t\n\t\t//Clear board and write/reset variables\n\t\tcurrentRound++;\n\t\tnbrOfPlayers = nextNbrOfPlayers;\n\t\tcurrentPlayerIndex = 0;\n\t\t\n\t\tfirstCardSelection = true;\n\t\ttimerNotRunning = true;\n\t\t\n\t\trows = nextRows;\n\t\tcolumns = nextColumns;\n\n\t\tspelare.removeAll(); \n\t\tspelplan.removeAll(); \n\t\t\n\t\t\n\t\t//rensar spelare vid nytt spel, garbage collectorn skter resten\n\t\tfor (int i = 0; i<5; i++){\n\t\t\tp[i] = null;\n\t\t}\n\t\t\n\t\t//inte jttesnyggt, men lyckades inte stta godt. antal spelare och rensa med reflexion\n\t\tfor (int i = 0; i<nbrOfPlayers; i++){\n\t\t\tp[i] = new Player(\"Spelare \" + (i+1), this);\n\t\t\tp[i].setWeightedScore(weightedScore_nyttSpel);\n\t\t\t\n\t\t}\n\t\t//singleplayerlge?\n\t\tif (this.nbrOfPlayers != 1){\n\t\t\tmultiplayer=true;\n\t\t} else {\n\t\t\tmultiplayer=false;\n\t\t}\n\n\t\tcurrentPlayer = p[0];\n\t\tcurrentPlayer.setActivePlayer(currentPlayer);\n\t\t\t\n\t\t\n\t\t//KORTHANTERING\n\t\tVerktyg.slumpOrdning(kort); //nya kort varje gng\n\t\tnbrOfCards = rows*columns-(rows*columns%2);\n\t\tKort[] spelkort = new Kort[nbrOfCards];\n\t\t\n\t\t//Dubblering, slumpning\n\t\tint cloneIndex = 0;\n\t\tfor (int i = 0; i<(nbrOfCards)/2; i++){\n\t\t\tspelkort[cloneIndex] = kort[i].copy(); //\"original\"\n\t\t\tcloneIndex++;\n\t\t\tspelkort[cloneIndex] = kort[i].copy(); //kopia\n\t\t\tcloneIndex++;\n\t\t}\n\t\tVerktyg.slumpOrdning(spelkort);\n\n\t\t//Placering p spelplan\n\t\tfor (int i = 0; i < nbrOfCards; i++){\n\t\t\t\tspelplan.add(spelkort[i]);\n\t\t\t\tspelkort[i].addActionListener(new ActionListener() {\n\t\t\t\t    public void actionPerformed(ActionEvent e) {\n\t\t\t\t    \tif (timerNotRunning){\n\t\t\t\t    \t\tcardAction((Kort)e.getSource());\n\t\t\t\t    \t}\n\t\t\t\t    }\n\t\t\t\t});\n\t\t}\n\n\t\t//gr plats fr spelare och kort\n\t\tspelare.setLayout(new GridLayout(nbrOfPlayers, 1)); //(5, 1)\n\t\tspelplan.setLayout(new GridLayout(rows, columns));\n\t\t\n\t    spelare.updateUI();\n\t\tspelplan.updateUI();    \n\t\t\n\t\tif (showingImage){\n\t\t\tcloseImage();\n\t\t}\n\t\t\n\t} //End METHOD nyttSpel\n\t\n\t//Anropas nr anvndaren klickar p ett kort\n\tprivate void cardAction (Kort Btn){\n\t\tcurrCard = Btn;\n\t\t\n\t\tcurrCard.setStatus(Kort.Status.SYNLIGT);\n\t\tif (firstCardSelection){\n\t\t\tfirstCardSelection = !firstCardSelection;\n\t\t\tcurrCard.setEnabled(false);\n\t\t\tprevCard = currCard;\n\t\t} else {\n\t\t\tfirstCardSelection = !firstCardSelection;\n\t\t\tcurrCard.setEnabled(false);\n\t\t\tmatchAttempt();\n\t\t}\n\t}\n\t\n\t//Korten lika?\n\tprivate void matchAttempt (){\n\t\tfinal int roundOnEntry = currentRound;\n\t\t\n\t\tif (prevCard.sammaBild(currCard)){\n\t\t\t\n\t\t\tcurrentPlayer.setFoundIcon(currCard.getIcon());\n\t\t\ttimerNotRunning = false;\n\t\t\tprevCard.setDisabledIcon(null);\n\t\t\tcurrCard.setDisabledIcon(null);\n\t\t\tcurrentPlayer.guessRight(this);\n\t\t\tnbrOfCards=nbrOfCards-2;\n\t\t\tplaySound();\n\t\t\t\n\t\t\tnew java.util.Timer().schedule( \n\t\t\t        new java.util.TimerTask() {\n\t\t\t            @Override\n\t\t\t            public void run() {\n\t\t\t            \t\n\t\t\t            \tif (currentRound == roundOnEntry){\n\t\t\t            \t\ttimerNotRunning = true;\n\t\t\t\t            \tprevCard.setStatus(Kort.Status.SAKNAS);\n\t\t\t\t    \t\t\tcurrCard.setStatus(Kort.Status.SAKNAS);\n\t\t\t\t    \t\t\tprevCard.setEnabled(false);\n\t\t\t\t    \t\t\tcurrCard.setEnabled(false);\n\t\t\t\t    \t\t\t//Alla kort hittade?\n\t\t\t\t    \t\t\tif (nbrOfCards == 0){\n\t\t\t\t    \t\t\t\troundEnd();\n\t\t\t\t    \t\t\t} \n\t\t\t            \t}\n\t\t\t            \n\t\t\t            }\n\t\t\t        }, \n\t\t\t        350\n\t\t\t);\n\t\t// !prevCard.sammaBild(currCard)\n\t\t} else {\n\t\t\ttimerNotRunning = false;\n\t\t\t\n\t\t\tnew java.util.Timer().schedule( \n\t\t\t        new java.util.TimerTask() {\n\t\t\t            @Override\n\t\t\t            public void run() {\n\t\t\t            \tif (currentRound == roundOnEntry){\n\t\t\t\t            \t//CARDLOCK\n\t\t\t\t            \tprevCard.setStatus(Kort.Status.DOLT);\n\t\t\t\t    \t\t\tcurrCard.setStatus(Kort.Status.DOLT);\n\t\t\t\t    \t\t\tprevCard.setEnabled(true);\n\t\t\t\t    \t\t\tcurrCard.setEnabled(true);\n\t\t\t\t    \t\t\t\n\t\t\t\t    \t\t\t//Change player\n\t\t\t\t    \t\t\tcurrentPlayer.guessWrong(Memory.this);\n\t\t\t\t    \t\t\ttimerNotRunning = true;\n\t\t\t\t    \t\t\tif (multiplayer){\n\t\t\t\t\t    \t\t\tif (currentPlayerIndex != (nbrOfPlayers-1)){\n\t\t\t\t\t    \t\t\t\tcurrentPlayerIndex++;\n\t\t\t\t\t    \t\t\t\tcurrentPlayer=p[currentPlayerIndex];\n\t\t\t\t\t    \t\t\t\tcurrentPlayer.setActivePlayer(p[currentPlayerIndex-1]);\n\t\t\t\t\t    \t\t\t\t\n\t\t\t\t\t    \t\t\t} else {\n\t\t\t\t\t    \t\t\t\tcurrentPlayer=p[0];\n\t\t\t\t\t    \t\t\t\tcurrentPlayer.setActivePlayer(p[currentPlayerIndex]);\n\t\t\t\t\t    \t\t\t\tcurrentPlayerIndex=0;\n\t\t\t\t\t    \t\t\t}\n\t\t\t\t    \t\t\t}\n\t\t\t            \t}\n\t\t\t            }\n\t\t\t        }, \n\t\t\t        1500 \n\t\t\t);\n\t\t}\n\t} //End METHOD matchAttempt\n\t\n\t//Vem vann?\n\tpublic void roundEnd(){\n\n\t\tPlayer vinnarN = p[0];\n\t\tString msg = \"\";\n\t\tif (multiplayer){\n\t\t\tfor (int i = 0; i<nbrOfPlayers; i++){\n\t\t\t\tif (vinnarN.getPlayerScore() < p[i].getPlayerScore())\n\t\t\t\t\tvinnarN=p[i];\n\t\t\t}\n\t\t\tmsg = vinnarN.getPlayerName() + \" vann med \" + vinnarN.getPlayerScore() + \" pong! \\nBsta pongen hittills: \" + lastScore;\n\t\t\t\n\t\t\tif (vinnarN.getPlayerScore() > lastScore){\n\t\t\t\tlastScore = vinnarN.getPlayerScore();\n\t\t\t}\n\t\t//singleplayer\n\t\t} else {\n\t\t\tString str = \"\";\n\t\t\tif (lastScore < p[0].getPlayerScore())\n\t\t\t\tstr = \"Grattis!\";\n\t\t\telse {\n\t\t\t\tstr = \"Tyvrr!\";\n\t\t\t}\n\t\t\tmsg = str + \" Du fick \" + p[0].getPlayerScore()+ \" pong! \\nBsta pongen frra gngen var: \" + lastScore;\n\t\t\tlastScore = p[0].getPlayerScore();\n\t\t}\n\t\t\n    \tObject[] options0 = {\"Nytt spel\", \"Forstt\", \"Avsluta\"};\n    \tint end = JOptionPane.showOptionDialog(spelplan,\n\t\tmsg, \"Spelet slut!\",JOptionPane.YES_NO_CANCEL_OPTION,\n\t\tJOptionPane.QUESTION_MESSAGE, null, options0, options0[0]);\n    \tswitch (end){\n    \t\tcase 0: nyttSpel();\n    \t\t\t\tbreak;\n    \t\tcase 1: //do nothing\n    \t\t\t\tbreak;\n    \t\tcase 2:\t//skulle kunna gra doClick p avsluta knappen\n    \t\t\t\tObject[] options2 = {\"Fortstt\", \"Avsluta\"};\n    \t\t\t\tint exit = JOptionPane.showOptionDialog(spelplan,\n    \t\t\t\t\"Verkligen avsluta? \", \"Avsluta\",JOptionPane.YES_NO_CANCEL_OPTION,\n    \t\t\t\tJOptionPane.QUESTION_MESSAGE, null, options2, options0[0]);\n    \t\t\t\tif (exit == 1){\n    \t\t\t\t\tSystem.exit(0); \n    \t\t\t\t}\n    \t\t\t\tbreak;\n    \t}\n\t\n\t} //End METHOD roundEnd\n\t\n\t//Visar bilden p spelarkortet\n\tpublic void viewImage (Icon pic, Player currShow){\n\t\tif (!showingImage){\n\t\t\tshowImage(pic);\n\t\t\tcurrentShowingPlayer = currShow;\n\t\t} else if (showingImage && currShow == currentShowingPlayer){\n\t\t\tcloseImage();\n\t\t\tcurrentShowingPlayer = null;\n\t\t} else {\n\t\t\tcloseImage();\n\t\t\tcurrentShowingPlayer = currShow;\n\t\t\tshowImage(pic);\n\t\t}\n\t}\n\n\tpublic void showImage(Icon pic){\n\n\t\tshowingImage = true;\n\t\t\t\n\t\tJLabel img = new JLabel();\n\t\timg.setIcon(pic);\n\t\tshowImage = new JInternalFrame(pic.toString());\n\t\tshowImage.setLayout(new BorderLayout());\n\t\tshowImage.setBackground(Color.white);\n\t\t\t\n\t\tJPanel dummy_left = new JPanel(), dummy_right = new JPanel();\n\t\tint dummyWidth = ( spelplan.getWidth()-pic.getIconWidth() )/2;\n\t\tdummy_left.setPreferredSize(new Dimension(dummyWidth, 1));\n\t\tdummy_right.setPreferredSize(new Dimension(dummyWidth, 1));\n\t\tdummy_left.setBackground(Color.white);\n\t\tdummy_right.setBackground(Color.white);\n\t\t\t\n\t\t//Tvinga fram rtt storlek p mittpanelen\n\t\tshowImage.add(dummy_left, BorderLayout.WEST);\n\t\tshowImage.add(img, BorderLayout.CENTER);\n\t\tshowImage.add(dummy_right, BorderLayout.EAST);\n\t\t\t\n\t\tmemory.remove(spelplan);\n\t\tmemory.add(showImage, BorderLayout.CENTER);\n\t\t\t\n\t\tshowImage.setVisible(true);\n\n\n\t}\n\n\t//Stng bildvisaren\n\tprivate void closeImage(){\n\t\tshowingImage = false;\n\t\tshowImage.dispose();\n\t\tmemory.remove(showImage);\n\t\tmemory.add(spelplan, BorderLayout.CENTER);\n\t}\n\t\n\t//ta emot argument, upprepa frsta raden i try inom if-sats fr att spela upp olika ljud\n    public static void playSound(){\n    try{\n        AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(new File(\"match.wav\").getAbsoluteFile());\n        Clip clip = AudioSystem.getClip();\n        clip.open(audioInputStream);\n        //tycker det lter alldeles fr mycket om den spelar ljud ven d man inte hittar ngot\n        clip.start();\n    }catch(Exception ex){\n        ex.printStackTrace();\n    }\n}\n    public int getNbrOfCards(){\n    \treturn nbrOfCards;\n    }\n    public void addPlayerCard(Component card){\n    \tspelare.add(card);\n    }\n\t\n\t@SuppressWarnings(\"unused\")\n\tpublic static void main(String[] args) {\n\t\t\n\t\tMemory m = new Memory();\n\t\t//Memory t1 = new Memory(\"test 1\", DISPOSE_ON_CLOSE);\n\t\t//Memory t2 = new Memory(\"test 2\", DISPOSE_ON_CLOSE);\n\t\t\n\t}\n\n} //End CLASS Memory\n"
    },
    "possibleGrades": [],
    "header": "Hello! This is the header.\n\nThis is usally a good place to put information which doesn't change between\nassignments, such as grading policy. I'm gonna use it to tell you about some\nfeatures instead:\n\nImport a template (Feedback -> Import Template), but not quite yet. It will\nreplace what you're reading now.\n\nImport groups from folder structures\n    1. A single root folder is assumed to contain a one folder per\n       group. Any subfolders of top-level subfolders will be group property.\n    2. Set file filters (e.g. java) to select the types of files to import.\n    3. Click done or close the window. The program will ask you if you want to\n       clear old groups or just import the new ones. Feedback will be created\n       for each group, based on the template.\n\nSick of writing the same thing over and over again?\n    1. Open the Pasta Editor (Ctrl+G) and click \"New Pasta\"\n    2. Create and add tags to organize items by content and by assignment.\n    3. Close the window. The program will ask if you want to use the new pasta.\n\nQuick insert (Pasta) at caret\n    1. Select a Pasta item (the search function is your friend) and select a\n       position in a student file.\n    2. Press (Ctrl+Q) or right-click the pasta list. The pasta will be pasted\n       into the student feedback referencing the current file and position.\n       Some examples are included to let you try this out.\n\nWhen youre done, you can export everything as individual files using (Ctrl+E).\nYou can also double-click (or right click) a group in the list to get a preview.",
    "content": "\n%HEADER%\n\n================================================================================\n<><><><><><><><><><><><><><><><> Player.java  <><><><><><><><><><><><><><><><><>\n================================================================================\n%FILE: Player.java%\nAt L123:  \nTry using a mouse transparent stack pane!\n\n\n%FOOTER%\n",
    "footer": "\nThis is the footer. This is a good place to include the signature tag.\nSimply including it in the body may cause issues with the automatic\ncreation of file tags. If the file tags are already present, its not an issue.\n\nThank you for using CopyPasta!\n%SIGNATURE%                                    \n\n\n  _______________________________\n /\\                              \\\n/++\\    __________________________\\\n\\+++\\   \\ ************************/\n \\+++\\   \\___________________ ***/\n  \\+++\\   \\             /+++/***/\n   \\+++\\   \\           /+++/***/\n    \\+++\\   \\         /+++/***/\n     \\+++\\   \\       /+++/***/\n      \\+++\\   \\     /+++/***/\n       \\+++\\   \\   /+++/***/\n        \\+++\\   \\ /+++/***/\n         \\+++\\   /+++/***/\n          \\+++\\ /+++/***/\n           \\+++++++/***/\n            \\+++++/***/\n             \\+++/***/\n              \\+/___/",
    "group": "memory_2013",
    "grade": "",
    "signature": "Richard Sundqvist (richard.sundqvist@live.se)",
    "notes": "They're different for each group.",
    "assignment": "",
    "done": false
  },
  {
    "files": {
      "TetrisModel.java": "/**\n * @author Richard Sundqvist\n * @group 31\n */\n\n//public static final Dimension SIZE = new Dimension(10, 16); rekommenderas i GameController, men det fungerar med 10x10.\n\nimport java.awt.Color;\nimport java.awt.event.KeyEvent;\nimport java.io.File;\n\nimport javax.sound.sampled.AudioInputStream;\nimport javax.sound.sampled.AudioSystem;\nimport javax.sound.sampled.Clip;\n\n/**\n * @author Admin\n * A model to run the game Tetris. Does not capture keystrokes or handle graphics.\n * Does not keep track of individual blocks after they're settled; No cascading pieces.\n */\npublic class TetrisModel extends GameModel {\n\n\t public static enum Tetromino {I (0), O (1), T (2), J (3), L (4), S (5), Z (6);\n\t\tpublic int index = 0;\n\t\t\n\t\tTetromino(int i){\n\t\t\tthis.index = i;\t\t\n\t\t}\n\t\t\n\t\tpublic static final Tetromino getTetromino(int i){\n\t\t\tswitch (i){\n\t\t\t\tcase 0:\n\t\t\t\t\treturn I;\n\t\t\t\tcase 1:\n\t\t\t\t\treturn O;\n\t\t\t\tcase 2:\n\t\t\t\t\treturn T;\n\t\t\t\tcase 3:\n\t\t\t\t\treturn J;\n\t\t\t\tcase 4:\n\t\t\t\t\treturn L;\n\t\t\t\tcase 5:\n\t\t\t\t\treturn S;\n\t\t\t\tcase 6:\n\t\t\t\t\treturn Z;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new IllegalArgumentException(\"Arguments [0, 6] permitted.\");\n\t\t\t}\n\t\t}\n\t} //End ENUM Shape\n\n\t/** Calculated based on the number of rows destroyed.*/\n\tprivate int score = 0;\n\n\t/** Block falls instantly if <code>true</code>.*/\n\tprivate boolean plummetTetromino = false;\n\t/** <code>true</code> if the next block failed to spawn. */\n\tprivate boolean gameOver = false;\n\t/** The shape currently falling. */\n\tprivate GameTile currentTetrominoTile = O_TILE;\n\tprivate Tetromino currentTetromino = Tetromino.O;\n\t\n\t/** The (x, y) coordinates at which the tetromino will be drawn next.*/\n\tprivate int nextTetrominoCoordinates[][] = new int[4][2];\n\t/** Current (x, y) coordinates for the 4 different tiles representing the current tetromino.*/\n\tprivate int currentTetrominoCoordinates[][] = new int[4][2];\n\t/** Temporary coordinates for a given piece. */\n\tint[][] tmpCoordinates = new int [4][2];\n\t\n\tprivate static final GameTile BLANK_TILE = new RectangularTile(new Color(255, 255, 255));\n\tprivate static final GameTile BLACK_TILE = new RectangularTile(new Color(0, 0, 0));\n\t\n\t/**Colors for the different tetrominos. Based on http://en.wikipedia.org/wiki/tetromino */\n\tprivate static final GameTile I_TILE = new RectangularTile(new Color(0, 255, 255));\n\tprivate static final GameTile O_TILE = new RectangularTile(new Color(255, 255, 0));\n\tprivate static final GameTile T_TILE = new RectangularTile(new Color(255, 0, 255));\n\t\n\tprivate static final GameTile J_TILE = new RectangularTile(new Color(0, 0, 255));\n\tprivate static final GameTile L_TILE = new RectangularTile(new Color(255, 128, 255));\n\t\n\tprivate static final GameTile S_TILE = new RectangularTile(new Color(0, 255, 0));\n\tprivate static final GameTile Z_TILE = new RectangularTile(new Color(255, 0, 0));\n\t\n\tint rotationPointX; //defines x-coord of the tile to rotate around.\n\tint rotationPointY; //defines y-coord of the tile to rotate around.\n\t\n\t//Storing these locally should be benefitial to performance.\n\tfinal int board_width = getGameboardSize().width;\n\tfinal int board_height = getGameboardSize().height;\n\t\n\t/**\n\t * Clears the board and spawns the first piece.\n\t */\n\tpublic TetrisModel () {\n\t\t\n\n\t\t// Blank out the whole gameboard\n\t\tfor (int i = 0; i < board_width; i++) {\n\t\t\tfor (int j = 0; j < board_height; j++) {\n\t\t\t\tsetGameboardState(i, j, BLANK_TILE);\t\t\n\t\t\t}\n\t\t}\n\t\t//playTheme(true);\n\t\t//create the first tetromino\n\t\tcurrentTetromino = Tetromino.getTetromino((int)(Math.random()*7)); //Randomize the first piece.\n\t\tspawnTetromino(currentTetromino, false);\n\t\t\n\t} //End constructor\n\t\n\t\n\tprivate void tetrominoControl (final int key) {\n\t\tswitch (key) {\n\t\t\tcase KeyEvent.VK_LEFT:\n\t\t\t\t//strafe left\n\t\t\t\ttetrominoXAxisMovement(-1);\n\t\t\t\tbreak;\n\t\t\tcase KeyEvent.VK_RIGHT:\n\t\t\t\t//strafe right\n\t\t\t\ttetrominoXAxisMovement(+1);\n\t\t\t\tbreak;\n\t\t\tcase KeyEvent.VK_A:\n\t\t\t\t//rush left\n\t\t\t\t//Would rather use double tap arrow key, but GameController does not support this.\n\t\t\t\ttetrominoXAxisMovement(-1);\n\t\t\t\ttetrominoXAxisMovement(-1);\n\t\t\t\tbreak;\n\t\t\tcase KeyEvent.VK_S:\n\t\t\t\t//rush right\n\t\t\t\ttetrominoXAxisMovement(+1);\n\t\t\t\ttetrominoXAxisMovement(+1);\n\t\t\t\tbreak;\n\t\t\tcase KeyEvent.VK_DOWN:\n\t\t\t\t//2x fall speed\n\t\t\t\ttetrominoYAxisMovement(1);\n\t\t\t\tbreak;\n\t\t\tcase KeyEvent.VK_SPACE:\n\t\t\t\t//plummet\n\t\t\t\tplummetTetromino = true;\n\t\t\t\tbreak;\n\t\t\tcase KeyEvent.VK_Z:\n\t\t\t\t//rotate anti-clockwise\n\t\t\t\trotateTetromino(false);\n\t\t\t\tbreak;\n\t\t\tcase KeyEvent.VK_X:\n\t\t\t\t//rotate clockwise\n\t\t\t\trotateTetromino(true);\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\t// Don't change direction if another key is pressed\n\t\t\t\tbreak;\n\t\t}\n\t} //End updateCommand METHOD\n\t\n\t@Override\n\tpublic void gameUpdate (int lastKey) throws GameOverException {\n\t\t\n\t\tif (gameOver){\n\t\t\tthrow new GameOverException(score);\n\t\t}\n\t\tcopySIArray(nextTetrominoCoordinates, tmpCoordinates);\n\t\t\n\t\tif (tetrominoYAxisMovement(1) == false){ //spawn a new piece if the current one cannot drop any further\t\t\n\t\t\tplaySound(0); //play at rest sound\n\t\t\tif (findCompleteRows()){\n\t\t\t\tplaySound(1); //Play only once if one or more rows are destroyed.\n\t\t\t}\n\t\t\tcurrentTetromino = Tetromino.getTetromino((int)(Math.random()*7)); //Spawn a new random piece.\n\t\t\tspawnTetromino(currentTetromino, false);\n\t\t\tif (locationObstructed(nextTetrominoCoordinates)){ \t\t\t\t\t\t\t//getGameboardState(board_width/2, 0) != BLANK_TILE\n\t\t\t\tspawnTetromino(currentTetromino, true);\n\t\t\t\tgameOver = true;\n\t\t\t\t//playTheme(false);\n\t\t\t\tplaySound(2); //Play game over sound.\n\t\t\t}\n\t\t\twriteTetromino(false);\n\t\t} else {\n\t\t\t//dropTetromino before updateCommand makes \"infinity spin\" more difficult.\n\t\t\tcopySIArray(nextTetrominoCoordinates, tmpCoordinates);\n\t\t\ttetrominoControl(lastKey);\n\t\t\twriteTetromino(true);\n\t\t}\n\t} //End gameUpdate METHOD\n\t\n\t/**\n\t * Rotates a piece around a given center point.\n\t * @param clockwise Performs a clockwise rotation by performing two anti-clockwise rotations if <code>true</code>.\n\t */\n\tprivate boolean rotateTetromino(boolean clockwise){\n\n\t\t//Solution based on http://en.wikipedia.org/wiki/Rotation_matrix and http://stackoverflow.com/questions/233850/tetris-piece-rotation-algorithm\n\t\t\n\t\t//Set rotation point.\n\t\tswitch (currentTetromino.index){\n\t\t\tcase 0: //I\n\t\t\t\trotationPointX = nextTetrominoCoordinates[2][0];\n\t\t\t\trotationPointY = nextTetrominoCoordinates[2][1];\n\t\t\t\tbreak;\n\t\t\tcase 1: //O\n\t\t\t\t//do nothing\n\t\t\t\treturn true;\n\t\t\tcase 2: //T\n\t\t\t\trotationPointX = nextTetrominoCoordinates[2][0];\n\t\t\t\trotationPointY = nextTetrominoCoordinates[2][1];\n\t\t\t\tbreak;\n\t\t\tcase 3: //J\n\t\t\t\trotationPointX = nextTetrominoCoordinates[2][0];\n\t\t\t\trotationPointY = nextTetrominoCoordinates[2][1];\n\t\t\t\tbreak;\n\t\t\tcase 4: //L\n\t\t\t\trotationPointX = nextTetrominoCoordinates[2][0];\n\t\t\t\trotationPointY = nextTetrominoCoordinates[2][1];\n\t\t\t\tbreak;\n\t\t\tcase 5: //S\n\t\t\t\trotationPointX = nextTetrominoCoordinates[2][0];\n\t\t\t\trotationPointY = nextTetrominoCoordinates[2][1];\n\t\t\t\tbreak;\n\t\t\tcase 6: //Z\n\t\t\t\trotationPointX = nextTetrominoCoordinates[2][0];\n\t\t\t\trotationPointY = nextTetrominoCoordinates[2][1];\n\t\t\t\tbreak;\n\t\t\tdefault:\n\t\t\t\tthrow new IllegalArgumentException(\"Unknown shape: \" + currentTetromino.toString() +\".\" );\n\t\t}\n\t\t\n\t\t//Perform a counter-clockwise rotation.\n\t\tfor (int i = 0; i < 4; i++){\n\n\t\t\t//Function assumes rotation around (0, 0): Apply offset.\n\t\t\ttmpCoordinates[i][0] = tmpCoordinates[i][0] - rotationPointX;\n\t\t\ttmpCoordinates[i][1] = tmpCoordinates[i][1] - rotationPointY;\n\t\t\t\n\t\t\t//Function assumes axes propagate to the top and to the right: invert y-axis coordinate. \n\t\t\ttmpCoordinates[i][1] = - tmpCoordinates[i][1];\n\t\t\t\n\t\t\t//Perform rotation.\n\t\t\tint tmpY = tmpCoordinates[i][0];\n\t\t\tint tmpX = - tmpCoordinates[i][1];\n\t\t\t//Once both calculations are completed the old values are no longer needed. Fetch results from temporary variables.\n\t\t\ttmpCoordinates[i][1] = tmpY;\n\t\t\ttmpCoordinates[i][0] = tmpX; \n\t\n\t        //Revert y-axis coordinate inversion.\n\t\t\ttmpCoordinates[i][1] = - tmpCoordinates[i][1];\n\t\t\t\n\t\t\t//Revert offset.\n\t\t\ttmpCoordinates[i][0] = tmpCoordinates[i][0] + rotationPointX;\n\t\t\ttmpCoordinates[i][1] = tmpCoordinates[i][1] + rotationPointY;\n\t\t}\n\t\t\n\t\t//Performs two counter-clockwise rotations to imitate a single clockwise rotation.\n\t\tif (clockwise){\n\t\t\trotateTetromino(false);\n\t\t\trotateTetromino(false);\n\t\t}\n\t\t\n\t\treturn moveTetrominoIfPositionClear(nextTetrominoCoordinates, tmpCoordinates);\n\t\n\t} //End rotateTetromino METHOD\n\n\n\t/**\n\t * Moves the current tetromino sideways,  if possible.\n\t * @param deltaX The desired distanse to move.\n\t */\n\tprivate boolean tetrominoXAxisMovement (int deltaX){\n\t\t\n\t\t\t//copySIArray(nextTetrominoCoordinates, tmpCoordinates);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\ttmpCoordinates[i][0] = nextTetrominoCoordinates[i][0] + deltaX;\n\t\t\t}\n\t\t\t\n\t\t\treturn moveTetrominoIfPositionClear(nextTetrominoCoordinates, tmpCoordinates); \n\t\t\n\t} //End strafeTetromino METHOD\n\t\n\t/**\n\t * Shifts the tetromino along the y-axis.\n\t * @param deltaY the desired fall distance.\n\t * @param plummetTetromino Fall instantly if <code>true</code>.\n\t */\n\tprivate boolean tetrominoYAxisMovement (int deltaY){\n\t\t\t\n\t\t\t//copySIArray(nextTetrominoCoordinates, tmpCoordinates);\n\t\t\t\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\ttmpCoordinates[i][1] = nextTetrominoCoordinates[i][1] + deltaY;\n\t\t\t}\n\n\t\t\tif (plummetTetromino){\n\t\t\t\tplummetTetromino = false;\n\t\t\t\t\n\t\t\t\twhile (tetrominoYAxisMovement(1));\n\t\t\t\t//Necessary only if the piece hits the edge\n\t\t\t\twriteTetromino(false);\n\t\n\t\t\t}\n\t\t\t\n  \t\t\treturn moveTetrominoIfPositionClear(nextTetrominoCoordinates, tmpCoordinates); \n\t\n\n\n\t} //End dropTetromino METHOD\n\t\t\n\t/**\n\t * Attempts to move a piece from source to target coordinates. Returns true if successful.\n\t * This method is possibly much less efficient than tetrominoCollision (see bottom), but should be easier to use.\n\t * @param sourceCoordinates The source location of the piece to move.\n\t * @param targetCoordinates The target location of the piece.\n\t * @return <code>True</code> if move was successful.\n\t */\n\tprivate boolean moveTetrominoIfPositionClear (int[][] sourceCoordinates, int[][] targetCoordinates){\n\t\t\n\t\t//Did it like this because i *think* its a performance boost compared to having it all in one loop.\n\t\tfor (int i = 0; i < 4; i++ ){\n\t\t\tif ( targetCoordinates[i][1] > board_height-1 || targetCoordinates[i][1] < 0 || //y-bounds\n\t\t\t\t targetCoordinates[i][0] > board_width-1 || targetCoordinates[i][0] < 0 ){ //x-bounds\n\t\t\t\t\t//Do nothing if target position is out of bounds\n\t\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\t\n\t\t//Clear source tiles.\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tfor (int j = 0; j < 2; j++){\n\t\t\t\tsetGameboardState(sourceCoordinates[i][0], sourceCoordinates[i][1], BLANK_TILE);\n\t\t\t}\n\t\t}\n\t\t\t\t\n\t\t//Since the source is cleared the piece can only be moved if all target tiles are blank.\n\t\tif (locationObstructed(targetCoordinates)){\n\t\t\t\n\t\t\t //If location is blocked, write piece back to source location.\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tfor (int j = 0; j < 2; j++){\n\t\t\t\t\tsetGameboardState(sourceCoordinates[i][0], sourceCoordinates[i][1], currentTetrominoTile);\n\t\t\t\t}\n\t\t\t}\n\t\t\t//System.out.println(\"false, collision\");\n\t\t\treturn false;\n\t\t\t\n\t\t} else { \n\t\t\t//If location is clear, write piece back to target location\n\t\t\t//Could be controlled using a 2nd parameter if you only wanted the return value, not the movement.\n\t\t\tcopySIArray(targetCoordinates, nextTetrominoCoordinates);\n\t\t\t//System.out.println(\"true\");\n\t\t\treturn true;\n\t\t}\n\t\t\t\n\t\t\t\n\t} //End checkCollision METHOD\n\n\n\t/**\n\t * Determines wether a given tetromino can be drawn at the location.\n\t * @return <code>true</code> if the entire tetromino does not collide at any point.\n\t */\n\tprivate boolean locationObstructed (int[][] targetLocation){\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\n\t\t\tif (getGameboardState(targetLocation[i][0], targetLocation[i][1]) != BLANK_TILE){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t} //End locationObstructed METHOD\n\n\t/**\n\t * Clears full lines, calls dropLines(..) to collapse above rows.\n\t */\n\tprivate boolean findCompleteRows (){\n\t\t\n\t\tboolean rowComplete = true;\n\t\tboolean ans = false;\n\t\tint collapsedRows = 0;\n\t\t\n\t\tfor (int row = board_height-1; row > -1;){\n\t\t\trowComplete = true;\n\t\t\tfor (int j = 0; j < board_width; j++){\n\t\t\t\tif (getGameboardState(j, row) == BLANK_TILE){\n\t\t\t\t\trow--;\n\t\t\t\t\trowComplete=false;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (rowComplete){\n\t\t\t\t//Enter if the row is complete\n\t\t\t\tans=true;\n\t\t\t\tcollapsedRows++;\n\t\t\t\tcollapseIntoRow(row);\n\t\t\t}\n\t\t\t\n\n\t\t}\n\t\tscore = score + 10*collapsedRows;\n\t\treturn ans;\n\n\t} //End dropLines METHOD\n\t\n\t\n\t/**\n\t * Move all rows about the given row one step down.\n\t * @param row the row to collapse into.\n\t */\n\tprivate void collapseIntoRow (int row){\n\t\t\n\t\tfor (; row > 1; row--){ //Drop all rows\n\t\t\tfor (int j = 0; j < board_width; j++){ //column\n\t\t\t\tsetGameboardState(j, row, getGameboardState(j, row-1)); //Get the above tile, write it to the given row.\n\t\t\t}\n\t\t}\n\t\t\n\t} //End dropLines METHOD\n\t\n\t/**\n\t\t * Draws a new tetromino at the top centre location.\n\t\t * @param arg The shape to draw.\n\t\t */\n\t\tprivate void spawnTetromino (Tetromino arg, boolean obsructed){\n\t\t\t\t\t\n\t\t\t//tetrominoesSpawned++;\n\t\t\t\n\t\t\tif (arg == Tetromino.I) {\n\t\t\t\tnextTetrominoCoordinates[0][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[0][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[1][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[1][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[2][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[2][1] = 2;\n\t\t\t\tnextTetrominoCoordinates[3][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[3][1] = 3;\n\t\t\t\tcurrentTetrominoTile = I_TILE;\n\t\t\t} else if (arg == Tetromino.O) {\n\t\t\t\tnextTetrominoCoordinates[0][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[0][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[1][0] = getGameboardSize().width/2-1;\n\t\t\t\tnextTetrominoCoordinates[1][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[2][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[2][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[3][0] = getGameboardSize().width/2-1;\n\t\t\t\tnextTetrominoCoordinates[3][1] = 1;\n\t\t\t\tcurrentTetrominoTile = O_TILE;\n\t\t\t} else if (arg == Tetromino.T) {\n\t\t\t\tnextTetrominoCoordinates[0][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[0][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[1][0] = getGameboardSize().width/2-1;\n\t\t\t\tnextTetrominoCoordinates[1][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[2][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[2][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[3][0] = getGameboardSize().width/2+1;\n\t\t\t\tnextTetrominoCoordinates[3][1] = 1;\n\t\t\t\tcurrentTetrominoTile = T_TILE;\n\t\t\t} else if (arg == Tetromino.J) {\n\t\t\t\tnextTetrominoCoordinates[0][0] = getGameboardSize().width/2-1;\n\t\t\t\tnextTetrominoCoordinates[0][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[1][0] = getGameboardSize().width/2-1;\n\t\t\t\tnextTetrominoCoordinates[1][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[2][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[2][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[3][0] = getGameboardSize().width/2+1;\n\t\t\t\tnextTetrominoCoordinates[3][1] = 1;\n\t\t\t\tcurrentTetrominoTile = J_TILE;\n\t\t\t} else if (arg == Tetromino.L) {\n\t\t\t\tnextTetrominoCoordinates[0][0] = getGameboardSize().width/2+1;\n\t\t\t\tnextTetrominoCoordinates[0][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[1][0] = getGameboardSize().width/2-1;\n\t\t\t\tnextTetrominoCoordinates[1][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[2][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[2][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[3][0] = getGameboardSize().width/2+1;\n\t\t\t\tnextTetrominoCoordinates[3][1] = 1;\n\t\t\t\tcurrentTetrominoTile = L_TILE;\n\t\t\t} else if (arg == Tetromino.S) {\n\t\t\t\tnextTetrominoCoordinates[0][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[0][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[1][0] = getGameboardSize().width/2+1;\n\t\t\t\tnextTetrominoCoordinates[1][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[2][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[2][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[3][0] = getGameboardSize().width/2-1;\n\t\t\t\tnextTetrominoCoordinates[3][1] = 1;\n\t\t\t\tcurrentTetrominoTile = S_TILE;\n\t\t\t} else if (arg == Tetromino.Z) {\n\t\t\t\tnextTetrominoCoordinates[0][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[0][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[1][0] = getGameboardSize().width/2-1;\n\t\t\t\tnextTetrominoCoordinates[1][1] = 0;\n\t\t\t\tnextTetrominoCoordinates[2][0] = getGameboardSize().width/2;\n\t\t\t\tnextTetrominoCoordinates[2][1] = 1;\n\t\t\t\tnextTetrominoCoordinates[3][0] = getGameboardSize().width/2+1;\n\t\t\t\tnextTetrominoCoordinates[3][1] = 1;\n\t\t\t\tcurrentTetrominoTile = Z_TILE;\n\t\t\t} else {\n\t\t\t\tthrow new IllegalArgumentException();\n\t\t\t}\n\t\t\t\n\t\t\tif (obsructed){\n\t\t\t\tcurrentTetrominoTile = BLACK_TILE;\n\t\t\t}\n\t\t} //End spawnTetromino METHOD\n\n\n\t/**\n\t * Commits the coordinates nextTetrominoCoordinates to the board. Assumes given values are valid.\n\t * @param clear Clears location of the previous shape if <code>true</code>.\n\t * @param nextTetrominoCoordinates The coordinates to write.\n\t */\n\tprivate void writeTetromino (boolean clear) {\n\t\t\t\t\n\t\t//Clear old shape\n\t\tif (clear){\n\t\t\tfor (int i = 0; i < 4; i++){\n\t\t\t\tsetGameboardState(currentTetrominoCoordinates[i][0], currentTetrominoCoordinates[i][1], BLANK_TILE);\n\t\t\t}\n\t\t}\n\t\t//draw shape at new location\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tsetGameboardState(nextTetrominoCoordinates[i][0], nextTetrominoCoordinates[i][1], currentTetrominoTile);\n\t\t\tcurrentTetrominoCoordinates[i][0] = nextTetrominoCoordinates[i][0];\n\t\t\tcurrentTetrominoCoordinates[i][1] = nextTetrominoCoordinates[i][1];\n\t\t}\n\t\t\t\n\t} //End METHOD writeTetromino\n\n\n\t/**\n\t * Copies the elements of a shapeIndex array.\n\t * @param src Source array.\n\t * @param dest Target array.\n\t */\n\tprivate void copySIArray(int[][] src, int[][] dest){\n\t\tfor (int i = 0; i < 4; i++){\n\t\t\tdest[i][0] = src[i][0]; //x value\n\t\t\tdest[i][1] = src[i][1]; //y value\n\t\t}\n\t}\n\t\n\t\n\t\n\t\n//\t//SOUND\n//\tprivate static AudioInputStream themeStream;\n//\tprivate static Clip themeClip;\n//    public static void playTheme(boolean start){\n//\t    try{\n//\t    \tthemeStream = AudioSystem.getAudioInputStream(new File(\"theme.wav\").getAbsoluteFile());\n//\t        themeClip = AudioSystem.getClip();\n//\t        themeClip.open(themeStream);\n//\t        //tycker det lter alldeles fr mycket om den spelar ljud ven d man inte hittar ngot\n//\t        if (start){\n//\t        \tthemeClip.start();\n//\t        } else {\n//\t        \tthemeClip.stop();\n//\t        }\n//\t      \n//\t    }catch(Exception ex){\n//\t        ex.printStackTrace();\n//\t    }\n//    }\n\n    public static void playSound(int soundIndex){\n\t    try{\n\t    \tAudioInputStream audioInputStream;\n\t        Clip clip = AudioSystem.getClip();\n\t        \n\t    \t//Select sound\n\t    \tswitch (soundIndex){\n\t    \t\tcase 0: //Tetromino at rest\n\t        \t\taudioInputStream = AudioSystem.getAudioInputStream(new File(\"at_rest.wav\").getAbsoluteFile());\n\t        \t\tbreak;\n\t    \t\tcase 1: //Completed row\n\t        \t\taudioInputStream = AudioSystem.getAudioInputStream(new File(\"complete_row.wav\").getAbsoluteFile());\n\t        \t\tbreak;\n\t    \t\tcase 2: //Game over\n\t    \t\t\tclip.stop();\n\t        \t\taudioInputStream = AudioSystem.getAudioInputStream(new File(\"game_over.wav\").getAbsoluteFile());\n\t        \t\tbreak;\n\t    \t\tdefault: //nosound\n\t    \t\t\t//System.out.println(\"Unknown sound: \" + soundIndex);\n\t        \t\treturn;\n\t    \t}\n\t        clip.open(audioInputStream);\n\t        clip.start();\n\t    }catch(Exception ex){\n\t        ex.printStackTrace();\n\t    }\n\t}\n\n} //End TetrisModel CLASS\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n//Rejected solution, all other methods have been rewritten to use moveTetrominoIfPositionClear(int[][], int[][]).\n\n///**\n// * Deterimines wether the current piece will collide. Returns <code>false</code> can move as requested.\n// * Works regardless of tetromino orientation.\n// * \n// * @param deltaX The requested change along the x-axis.\n// * @param deltaY The requsted change along the y-axis.\n// * @return <code>true</code> if performing the requested position change would cause a collision or move the piece out of bounds.\n// */\n//private boolean tetrominoCollision (int deltaX, int deltaY, int[][] arg){\n//\t\n//\tfor (int i = 0; i < 4; i++ ){\n//\t\tif ( (arg[i][1]+deltaY > board_height-1 || \n//\t\t\t\targ[i][1]+deltaY < 0 ||\n//\t\t\t\targ[i][0]+deltaX > board_width-1 ||\n//\t\t\t\targ[i][0]+deltaX < 0) ){\n//\t\t\treturn true;\n//\t\t}\n//\t\t\n//\t\tif (getGameboardState(arg[i][0]+deltaX, arg[i][1]+deltaY) != BLANK_TILE){\n////\t\t\tif (tetrominoesSpawned>1 && currentTetrominoIndex[0][1] > 2){\n////\t\t\t\tSystem.out.println(\"nu!\");\n////\t\t\t}\n//\t\t\tfor (int j = 0; j < 4; j++){\n//\t\t\t\tif ( deltaY != 0 && arg[i][0] == currentTetrominoCoordinates[j][0] && arg[i][1]+deltaY == currentTetrominoCoordinates[j][1] ){ //deltaY != 0 && \n//\t\t\t\t\t//The shape collided with itself in the offending position, exit current iteration on i.\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\tif ( deltaX != 0 && arg[i][1] == currentTetrominoCoordinates[j][1] && arg[i][0]+deltaX == currentTetrominoCoordinates[j][0] ){ //deltaX != 0 &&\n//\t\t\t\t\t//The shape collided with itself in the offending position, exit current iteration on i.\n//\t\t\t\t\tbreak;\n//\t\t\t\t}\n//\t\t\t\tif (j>=3){\n//\t\t\t\t\t//The shape did not find itself in the offending position, return true.\n//\t\t\t\t\treturn true;\n//\t\t\t\t}\n//\n//\t\t\t}\n//\t\t}\n//\t}\n//\t//\n//\treturn false;\n//} // end tetrominoCollision METHOD\n",
      "lab1_del1.txt": "/**\n * @author Richard Sundqvist\n * @group 31\n */\n\nFrgor att besvara:\n----------------------------------------------------------------------------------------------------------------------------------------------\n*Vad r skillnaden p GoldModel och GameModel, och hur r de relaterade till varandra?\n----------------------------------------------------------------------------------------------------------------------------------------------\n\tGameModel r en absrakt klass - den kan inte instansieras. GoldModel utkar GameModel\n\toch nyttjar dess metoder fr att kra spelet.\n----------------------------------------------------------------------------------------------------------------------------------------------\n*Vilken klass utfr sjlva ritandet av 'Gold coins' i spelet 'Gold game'?\n----------------------------------------------------------------------------------------------------------------------------------------------\n\tRoundTile klassen, som i sin tur nyttjar Javas Graphics och Graphics2D paket.\n----------------------------------------------------------------------------------------------------------------------------------------------\n*Vilken klass r det som anropar (=anropas?) fr detta ritande?\n----------------------------------------------------------------------------------------------------------------------------------------------\n\tGraphics(.fillOval(..)) anropas av RoundTile.\n\tGoldModel anropar RoundTile.\n----------------------------------------------------------------------------------------------------------------------------------------------\n*Vad r syftet med GameFactory och hur kan den utvidgas fr att f med Snake game? ( Endast ett kort svar behvs.)\n----------------------------------------------------------------------------------------------------------------------------------------------\n\tHller reda p vilka spel som kan skapas. Utka createGame(..) och getGameNames() med kopior av Gold dr \"Gold\" ersatts av t.ex. \"Snake\".\n----------------------------------------------------------------------------------------------------------------------------------------------\n*Var terfinns berkningen och kontrollen av 'gold eaters' rrelser?\n----------------------------------------------------------------------------------------------------------------------------------------------\n\tRrselseriktningarna definieras och berknas i GoldModel(.updateDirection(..)). Sjlva tangentenbordstryckningen fngas upp i \n\tGameController klassen, som skickar en enda tangent (den senaste) till spelets update metod.\n----------------------------------------------------------------------------------------------------------------------------------------------\n*Hur lagras ett spelbrde och i vilken klass?\n----------------------------------------------------------------------------------------------------------------------------------------------\n\tI GameModel, som ett 2D-flt (gameboardState).\n----------------------------------------------------------------------------------------------------------------------------------------------\n*Beskriv arbetsfldet av programmet. Detta kan gras genom att skissa p hur kontrollen fldar genom olika klasser och metoder.\n----------------------------------------------------------------------------------------------------------------------------------------------\n\tMain: \t\t\tEn ny JFrame skapas, som bara visar en GUIView.\n\tGUIView:\t\tKnappar etc skapas och placeras i botten. Spelet tilldelas en kontroller och sjlva spelet\n\t\t\t\t\tplaceras ovanfr. Lyssnare placeras p \"Start Game\" knappen. Nr anvndaren trycket p knappen anropas\n\t\t\t\t\tStartGameListener, som skapar en helt ny instans av spelet (icke-statisk highscore etc. allts inte\n\t\t\t\t\tmjligt om man lagrar den i t.ex GoldModel.)\n\tGameFactory:\tHller en lista med spel och skapar+returnerar ett spel som vljs med en strng. Borde inte denna\n\t\t\t\t\tklass vara final? Den behver vl inte instansieras?\n\t(GameModel:\t\tInnehller \"brdet\" och funktioner fr att ndra utseendet p rutorna.)\n\tGoldModel:\t\tDefinierar och placerar mynt och myntjgare mha GameTile.\n\tGameController:\trun metoden hller spelet igng till dess att isRunning stts till false (spelet slut) eller till dess att spelet\n\t\t\t\t\tstngs av. gameModel's ( i detta fall GoldModel) update metod anropas och skickar med den senaste tangenten, GoldModel\n\t\t\t\t\tansvarar sedan fr att jgaren rr sig t rtt hll, slumpning av nya myntpositioner och kontroll av kollision mellan\n\t\t\t\t\tmynt och jgare. Tangentbordslyssnaren ligger och kr samt uppdaterar lastKeyPress hela tiden, det r bara den senaste\n\t\t\t\t\ttangenten som trycktes som skickas vidare till spelet var updateInterval:e millisekund.\n----------------------------------------------------------------------------------------------------------------------------------------------\n*Ge en plan fr hur du tnker fortstta med deluppgift 2. Vilka klasser kommer du att skriva\n och vad kan du teranvnda.\n----------------------------------------------------------------------------------------------------------------------------------------------\n\tJag ska frska skriva Tetris och br ha nytta av allt utom RoundTile. Man ska kunna rotera formerna med z och x, flytta dem i\n\tsidled med pilarna samt f den att falla x ggr s fort med nedpil. Det kommer inte g att se vilken(a) bitar som kommer nst.\n\t\n\tP.g.a. av hur GameController r utformad kommer man bara kunna gra en sak t gngen, t.ex. rotera och flytta i sidled men inte\n\tbde och samtidigt. Jag mste skriva en metoder fr att kontrollera om formen i\trrelse ligger mot en annan i y-led, samt leta fulla\n\trader och skapa en ny form nr ovanstende metod returnerar true.\n\t\n\tP ngot stt mste\tjag ocks f raderna ovan att falla nr en tas bort, lyckligtvis behver jag inte kontrollera bit fr bit utan jag\n\tkan lta allt falla\tsom ett enda block. Kanske r tetris utformat s fr att de hade problem med att f de indivudella bitarna att falla\n\tfr sig nr spelet skapades\tfrn brjan?\n\t\n\tAtt rotera bitarna kan bli svrt, har tnkt frska detta med rotationsmatriser d jag inte tycker det vore snyggt att rotera delarna\n\t\"fr hand\", vilket jag tror jag mste gra nr jag frst skapar biten.\n\t\n\tJag tnker dessutom fastna p en massa problem jag inte frutsptt.\n----------------------------------------------------------------------------------------------------------------------------------------------\n"
    },
    "possibleGrades": [],
    "header": "Hello! This is the header.\n\nThis is usally a good place to put information which doesn't change between\nassignments, such as grading policy. I'm gonna use it to tell you about some\nfeatures instead:\n\nImport a template (Feedback -> Import Template), but not quite yet. It will\nreplace what you're reading now.\n\nImport groups from folder structures\n    1. A single root folder is assumed to contain a one folder per\n       group. Any subfolders of top-level subfolders will be group property.\n    2. Set file filters (e.g. java) to select the types of files to import.\n    3. Click done or close the window. The program will ask you if you want to\n       clear old groups or just import the new ones. Feedback will be created\n       for each group, based on the template.\n\nSick of writing the same thing over and over again?\n    1. Open the Pasta Editor (Ctrl+G) and click \"New Pasta\"\n    2. Create and add tags to organize items by content and by assignment.\n    3. Close the window. The program will ask if you want to use the new pasta.\n\nQuick insert (Pasta) at caret\n    1. Select a Pasta item (the search function is your friend) and select a\n       position in a student file.\n    2. Press (Ctrl+Q) or right-click the pasta list. The pasta will be pasted\n       into the student feedback referencing the current file and position.\n       Some examples are included to let you try this out.\n\nWhen youre done, you can export everything as individual files using (Ctrl+E).\nYou can also double-click (or right click) a group in the list to get a preview.",
    "content": "\n%HEADER%\n\n\n================================================================================\n<><><><><><><><><><><><><><><> TetrisModel.java <><><><><><><><><><><><><><><><>\n================================================================================\n%FILE: TetrisModel.java%\nAt L547, At L617:\nDo not leave vast amounts of commented code in the\nfiles, thats what version control is for.\n\n%FOOTER%\n",
    "footer": "\nThis is the footer. This is a good place to include the signature tag.\nSimply including it in the body may cause issues with the automatic\ncreation of file tags. If the file tags are already present, its not an issue.\n\nThank you for using CopyPasta!\n%SIGNATURE%                                    \n\n\n  _______________________________\n /\\                              \\\n/++\\    __________________________\\\n\\+++\\   \\ ************************/\n \\+++\\   \\___________________ ***/\n  \\+++\\   \\             /+++/***/\n   \\+++\\   \\           /+++/***/\n    \\+++\\   \\         /+++/***/\n     \\+++\\   \\       /+++/***/\n      \\+++\\   \\     /+++/***/\n       \\+++\\   \\   /+++/***/\n        \\+++\\   \\ /+++/***/\n         \\+++\\   /+++/***/\n          \\+++\\ /+++/***/\n           \\+++++++/***/\n            \\+++++/***/\n             \\+++/***/\n              \\+/___/",
    "group": "tetris_2013",
    "grade": "",
    "signature": "Richard Sundqvist (richard.sundqvist@live.se)",
    "notes": "Notes can be made here.",
    "assignment": "",
    "done": false
  }
]